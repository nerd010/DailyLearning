
<strong>区块链技术的流派</strong>

未战先谋局，你想投入区块链开发这个领域，至少先要搞清楚现在有哪些玩家，各自的主张和实力如何。
划分区块链技术流派并无一定之规，据我所见，或可有以下四种方式：
第一是按照节点准入规则，划分为公有链、私有链和联盟链。公有链的代表自然是比特币和以太坊，私有链则以R3 Corda声名最盛，联盟链的代表作品是Hyperledger名下的Fabric。公有链注重匿名性与去中心化，而私有链及联盟链注重高效率，而且还往往设置了准入门槛。公有链、私有链与联盟链之间的这些不同都在技术中有所体现，比如私有链和联盟链假设节点数目不大，可以采用PBFT算法来形成共识。而公有链假设有大量且不断动态变化的节点网络，用PBFT效率太低，只能采用类似抽彩票的算法来确定意见领袖。这就意味着，私有链与联盟链很难变成公有链，而用公有链来作联盟链或私有链虽然容易，却也并非即插即用。此种差异，学者不可不察。
第二是按照共享目标，划分为共享账本和共享状态机两派。比特币是典型的共享账本，而Chain和BigchainDB也应属此类，这几个区块链系统在各个节点之间共享一本总账，因此对接金融应用比较方便。另一大类区块链系统中，各个节点所共享的是可完成图灵完备计算的状态机，如以太坊、Fabric，它们都通过执行智能合约而改变共享状态机状态，进而达成种种复杂功能。
第三是按照梅兰妮 · 斯旺所描述的代际演进，将区块链系统分为1.0、2.0和3.0三代。其中1.0支撑去中心化交易和支付系统，2.0通过智能合约支撑行业应用，3.0支撑去中心化的社会体系。比特币和Chain应属于区块链1.0系统，而以太坊和Fabric是区块链2.0系统，目前尚无成功的区块链3.0系统出现，不成功的尝试倒是有那么一个，就是著名的The DAO。 
第四是按照核心数据结构，分为区块链和分布式总账两派。区块链这一派在系统中真的实现了一个区块的链作为核心数据结构，而分布式总账这一派，只是吸取了区块链的精神，并没有真用一条区块链作为核心数据结构，或者虽然暂时用了，但声明说吾项庄舞区块链，意在分布式总账耳，若假以时日，因缘际会，未尝不可取而代之也。

<strong>主流区块链技术平台</strong>

了解流派划分，仍是只能用来指点江山，吹牛论道，要动手，总要有个切入点。区块链货币据说已经有上千个了，但值得关注的技术平台大概只有数十个，而如果要进入区块链开发领域，打下一个好基础，练出一身好功夫，捞到几个好offer，则值得深入研究学习的平台，屈指可数。
首先当然是比特币。比特币作为区块链的第一个也是目前为止最成功、最重要的样板工程，已经上线运行了八年多，本身没有发生任何严重的安全和运维事故，其稳定与强悍堪称当代软件系统典范。比特币Bitcoin Core是一个代码质量高、文档良好的开源软件，从学习区块链原理、掌握核心技术的角度来说，Bitcoin Core是最佳切入点，能够学到原汁原味的区块链技术。当然，Bitcoin Core是用C++写的，而且用了一些C++11和Boost库的机制，对学习者的C++水平提出了较高的要求。
学习比特币平台开发还有一个优势，就是可以对接繁荣的比特币技术社区。目前围绕比特币进行改进和提升的人很多，人多力量就大，诸如隔离验证、闪电网络、侧链等比较新的想法和技术，都率先在比特币社区里落地。比如侧链技术的主要领导者Blockstream是由密码学货币元老Adam Back领衔的，而Blockstream是Bitcoin Core最大的贡献者之一，所以一些有关侧链的技术在比特币社区里讨论最充分。
但比特币作为一个典型的区块链1.0系统，是不是支撑其他类型区块链应用的最佳技术平台，存在很大的争议。另外，也不是所有人都有能力和必要精通区块链底层技术。所以对那些急于冲到区块链领域里做（quān）事（qián）的人来说，可能更直截了当的学习目标是以太坊和Hyperledger Fabric。
在以太坊上面用Solidity进行的智能合约开发是切入区块链开发最简单的方式，没有之一。以太坊的理想非常宏大，由于配备了强大的图灵完备的智能合约虚拟机，因此可以成为一切区块链项目的母平台，是驮住整个区块链世界的大乌龟。在以太坊上开发一个类似比特币的加密货币，是一个不折不扣的小目标。一般有经验的开发者在文档指导下，半天到一天即可入门。问题在于，入门以后又如何？靠写Solidity是否就可以包打天下？这是大大存疑的。我们也可以反过来说，如果以太坊+Solidity是区块链的终极解决方案，那么怎么还会出现那么多区块链技术门派呢？特别是，以太坊似乎并没有给现实世界中巨型的中心化组织们留下一条活路，这种彻底不妥协的革命态度有可能也成为以太坊推广的障碍。
当前以太坊项目的开发进展并不顺利。一个比较突出的问题是项目过多，力量分散，导致项目质量参差不齐。但尽管如此，跟其他区块链2.0平台相比，以太坊提供的开发环境是最简单最完善的。初学区块链的人绝对有必要学习以太坊，从而对区块链和智能合约建立起一个最“正宗”的认识。
主流区块链技术平台的第三支就是Fabric，它是Hyperledger的第一个也是最知名的孵化项目。Fabric最早来自IBM的Open Blockchain项目，到2015年11月，IBM将当时已经开发完成的44,000行Go语言代码交给Linux基金会，并入Hyperledger项目之中。在2016年3月一次黑客马拉松中，Blockstream和DAH两家公司将各自的代码并入Open Blockchain，随后改名为Fabric。到目前为止，Fabric与Intel提供的Sawtooth Lake并列为Hyperledger的一级孵化项目，但前者得到的关注远超后者。
从技术角度来说，Fabric思路不错，重点是满足企业商用的需求，比如解决交易量问题。众所周知，比特币最大的短板是它每秒钟7个交易的上限，完全无法满足现实需要。而Fabric目标是实现每秒钟10万交易，这个量接近刚刚过去的双十一交易量瞬时峰值，完全可以满足正常条件下的行业级应用。Fabric用Go语言开发，也提供多种语言的API。特别值得一提的是，Fabric比较充分地运用了容器技术，比如其智能合约就运行在容器当中。这也是Go语言带给Fabric的一项福利，因为Go语言静态编译部署的特征很适合开发容器中的程序。
Fabric还有一些特点，比如其membership服务可以设置节点准入审查，这是典型的联盟链特征。再比如其共识算法是可定制的。Fabric自带PBFT共识算法实现，但是PBFT的算法效率是O(n²)，其中n是节点数量。因此PBFT用在节点数量受限的联盟链里是没有问题的，但用在公有链里效率过低。
Fabric的短板是体系较为复杂，虽有文档，但缺少经验的开发者学习起来障碍比较大。然而由于其定位清楚，迎合了不少企业的心态，所以已经有多家机构在基于Fabric秘密研发行业内的联盟链项目。

<strong>小众门派</strong>

上述区块链开发的三大主流平台，从活跃度、受关注和参与人数来说，远远超过其他平台。但俗话说莫欺少年穷，一些眼下还默默无闻的平台也不容忽视。
Hyperledger的另一个一级孵化项目Sawtooth Lake是Intel开发的区块链平台，是一个很少被关注的项目，大概是因为被同在Hyperledger旗下的Fabric给掩盖了，再加上名字拗口，所以很少看到有人讨论它，项目活跃度也不高。但其实Sawtooth Lake是一个挺有想法的区块链项目，设计十分精心。它以数字金融资产管理为目标，整体架构清晰，模块化程度高，因此可定制能力也强。概念上独创了“交易族（transaction family）”概念，而且还支持PoET和Quorum两种共识机制。当节点数量很多（公有链环境）时，使用第6代Intel Core CPU所提供的SGX扩展功能提供一种称为时间流逝证明（PoET）的机制来形成共识，这种机制与比特币所采用的PoW同属“抽彩票”式的共识算法，但杜绝了通过ASIC专用硬件“作弊”的可能性，排除了比特币出现的算力过于集中的隐患，可靠性由Intel CPU硬件来保障，是公有链系统里很有价值的一个共识机制。另一方面，当节点数量少且受控时，Sawtooth Lake可以采用Quorum共识机制，这是由Ripple提出并验证的共识机制，非常适合于联盟链场景，这样Sawtooth Lake就摇身一变成为很好用的联盟链了。
Sawtooth Lake采用Python开发，并提供了Java SDK。由于这两种语言的流行度，实际上它应该有很大的潜在开发者人群。事实上，R3 CEV曾经测试过Sawtooth Lake并进行了成功的证券交易实验。当前它主要的问题是受关注度不足，不知Intel是否有足够的耐心和毅力坚持到底。如果Intel战略更明确一些，支持力度更大一些，我建议大家可以对它投以更多的关注。
R3 Corda是一个备受关注的分布式账本项目。R3是由数十家银行和金融机构支持的区块链企业，融资上亿美元，号称汇集了一票高手，潜心研究符合金融行业需求的分布式账本系统。Corda是R3分布式账本系统中的核心，在千呼万唤之后，于11月30日正式开源。
Corda采用JetBrain原创的小众语言Kotlin开发，对Java世界敞开大门，这是令人点赞的。此外，Corda更重要的特色是其与现有世界里大银行、大型中心机构的全面妥协、全面合作的姿态，这与以太坊革命无罪、造反有理的形象形成鲜明对比。Corda在设计中有多项独特考虑，就是为了对接现有的业务规则。比如在其他几乎所有区块链平台里，每一个交易对于各节点来说都是可见的，可见才能验证，能验证才谈得上共识，所以交易的全网可见性是顺理成章的。但是现实世界里金融机构之间的交易，只有交易相关方才能看到交易详情，工行与建行的一笔交易，绝无必要让招行看到。为了对接这个现实，Corda设计了与众不同的机制，牺牲了交易验证的全局可见性，确保只有交易相关方才能看到和验证交易本身。可是另一方面，银行业务是被重度监管的业务，不能因为你用了区块链系统，就把洋洋洒洒的巴塞尔协议晾在一边，监管机构的职能如何体现？这是其他区块链系统里考虑不多的。而Corda设计了独特的Notary和Oracle节点，为监管体系进入留下了空间。仔细品味，这些都是给现实世界当中的大机构预留的美差。这些设计上的考虑，无疑大大增强了Corda被现有大型金融机构采纳的机会。不过这一切看上去很美好，但目前Corda的实现基本上是个花架子，设想的种种，不少处于TODO状态。
另外两个值得点名的区块链门派分别是Chain和BigchainDB。前者跟Visa有合作，后者是一个基于RethinkDB开发的分布式账本，两者各有各的思路和特色，也拿到了为数可观的投资，不排除未来能有大的发展。限于篇幅，在这里不展开介绍了。

<strong>区块链开发所需具备的技术基础</strong>

可以预见，未来从事区块链开发的主要有三类开发者，一类是开发基于区块链的Web或移动App，这种开发者所需要的技能与今天的Web和移动开发者并无二致，这里就不赘述了。
第二类开发者是开发智能合约的。这类开发者使用类似Solidity这样的智能合约语言，或者直接用Go、Java、Python等语言开发。开发智能合约所要求的语言和算法技术水平不高，什么并发、多线程之类的东西一般用不到，普通开发者均可胜任。但是智能合约的难点在于业务与安全。本质上智能合约就是以代码写成的商业合同，必须对于业务有非常清晰的认识，对于安全有着深刻的理解，才能够写出正确的智能合约。因此，我认为未来智能合约的开发者，可能反而是具体应用领域的行业专家出身居多，因为让他们掌握Python语言，远比让程序员去理解进出口贸易规则或者商业票据业务要容易得多。
第三类开发者，就是区块链核心应用系统和核心平台的开发者。这部分人当然必须是技术高手，按现在通俗的说法，得是后端专家。从语言上讲，C++、Java、Python、Go、JavaScript都有可能要触及。从基础知识来说，要求对密码学、分布式系统、网络编程、系统架构和部署都有相当程度的理解和实践经验。这种开发者显然将是区块链技术浪潮当中的弄潮儿，也将是最大的受益者之一。
特别要点一下密码学。密码学是大多数开发人员的短板，但若要在区块链核心技术领域搞出能够碾压竞品的创新点，密码学是最有可能出成果的地方。不用说搞出什么密码学突破，就是将密码学现有成果充分运用在区块链里，都可能会搞出一些逆天的创新来。比如用零知识证明协议（zero-knowledge proof）构造高度匿名化的区块链系统，比如用私有计算外包（private computing outsourcing）技术让别的节点既能够验证交易，又对交易本身的内容一无所知，这都是能够激发大量商业模式创新的技术，等待密码学黑客们发掘和实现。因此，我相信密码学成为显学的时代即将到来。 
区块链是一项前景无限、极具颠覆性和想象空间的技术，它有潜力带来一个完全不同的商业时代，塑造新一代的互联网，也有可能被传统势力合谋异化。无论如何，区块链为创业者和程序员提供了又一次弄潮的机会，在这片蓝海上将演出一场怎样的大戏，我们且拭目以待。加密货币，特别是比特币，几乎从各个方面都得到了大量关注：规则、管理、税务、技术、产品创新等等，不胜枚举。“点对点（去中心化）电子现金系统”的概念颠覆了我们以前对货币和金融所持有的设想。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864c5920c350.png" alt="图1" title="图1" />
即便如此，把数字货币方面搁到一边，还有一个可以说是更有趣更深远的创新，即底层的区块链技术。无论你对比特币或是它的山寨币衍生品有什么看法，作为一种货币和价值存储手段，它们背后的运作基础都来自于中本聪概括的区块链原理：
我们运用点对点网络提出了重复花费问题的解决方案。网络通过将交易散列到一个进行中的基于散列的工作量证明链，来对交易进行时间戳标记，并形成一个记录，这个记录只有在重做工作量证明的情况下才能被改变。最长的链不仅作为它所见证事件发生时序的证据，而且也证明它来自最大的CPU功率池……网络本身要求架构最小化。
区块链对任何“货币”都是不可知的。事实上，它可以适用于促成很多其他使用案例。因此，理解“最小可行区块链”背后的方法和原理是有好处的：
以下将从头开始解释为什么需要特定的部分（数字签名、工作量证明、交易区块），以及它们如何集合起来形成具有卓越性能的“最小可行区块链”。

<strong>用三式记账法保障交易安全</strong>

Alice和Bob是集邮爱好者，偶尔会做做交易。如果双方都看到喜欢的东西，可以当场协商完成交换。换言之，这是个简单的以物易物的系统。
有一天Bob拿来一枚邮票，Alice觉得她必须要收藏，但问题是Bob对Alice所提供的交换物不是特别感兴趣。Alice沮丧不已，她继续和Bob协商，最后达成一致：他们做个单方交易，Bob先把邮票给Alice，Alice承诺以后再偿还Bob。
Bob和Alice已经认识有一阵子了， 但是为了确保两个人都信守承诺（主要是Alice），他们同意让朋友Chuck来对交易“进行公证”。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864c5d2b1d51.png" alt="图2" title="图2" />
他们把图2这个可以表明Bob给了Alice一枚“红色邮票”的交易收据做了三个副本（三方各持一份）。Bob和Alice可以用收据来记录他们的交易， Chuck存储副本作为交易证据。这个设定很简单，但其中有一些很重要的属性：
1. Chuck可以鉴定Alice和Bob两个人的真实性，以确保不会有人在他们不知情的情况下蓄意伪造交易。
2. Chuck账簿中的收据证明了交易发生。如果Alice声称交易从未发生，那么Bob可以去找Chuck，用他的收据来证明Alice说谎。
3. 如果Chuck的账簿中没有收据，就证明交易未发生过。Alice和Bob都不能伪造交易。他们可以伪造交易收据，声称对方说谎，但同样的，他们可以去找Chuck，查看他的账簿。
4. Alice和Bob都不能篡改当前的交易。如果任意一方篡改了交易，他们可以去Chuck那儿，用储存在Chuck账簿中的副本核实他们的副本。
以上操作就是“三式记账法”，操作简便，对参与双方都能提供很好的保障。但你也看到了它的缺点，对吧？我们对中间人寄予了很大的信任。如果Chuck决定和另一方串通，那么整个系统就土崩瓦解了。

<strong>用公钥基础设施（PKI）保障交易安全</strong>

Bob不满于使用“可靠中间人”的不安全性，他决定研究一下，发现公钥密码可以免去使用中间人的需要！这里解释一下：
公钥密码，也叫做不对称密码，指的是一种密码算法，它需要两个单独的钥匙，一个是秘密的（私有的），另一个是公共的。尽管这个钥匙对应的两部分不同，但有数学联系。公钥用于对纯文本加密或者查验数字签名；私钥用于解密密码文本或者创建数字签名。
运用第三方（Chuck）的原本意图是要确认有三个属性：
1. 验证真实性： 不能有恶意的一方伪装成其他人。
2. 不可否认性： 事实发生后，参与方不能声称交易没有发生过。
3. 完整性：事实发生后，不能再修改交易收据。

结果是，公钥密码可以满足以上所有要求。简单地说，工作流程如图3所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cc7775b8b.png" alt="图3" title="图3" />
1. Alice和Bob分别生成一个固定的公钥-私钥对。
2. Alice和Bob公布出他们的公钥。
3. Alice以纯文本的形式写一个交易收据。
4. Alice用她的私钥对交易信息的纯文本进行加密。
5. Alice在密码文本上添加一个“由……签名”的纯文本备注。
6. Alice和Bob都储存相应的输出结果。
注意只有在多方参与的时候才需要第五步：如果你不知道是谁签署了信息，就不知道该用谁的公钥来解密，这个问题很快就会变得有关紧要。
这看起来像是没什么特别理由的大量工作，但我们还是来检验一下新收据的属性：
1. Bob不知道Alice的私钥，但问题不大，因为他可以查询她的公钥（公钥是全世界共享的），然后用公钥来解密交易的密码文本。
2. Alice并不是真的在给交易内容“加密”，而是通过使用她的私钥给她“签名”的交易编码：任何人都可以用她的公钥对密码文本进行解密，由于她是唯一拥有私钥的人，这个机制保证了只有她能生成交易的秘密文本。

Bob或针对这个问题的任何其他人，如何获得Alice的公钥？有很多种方法来分发私钥——例如，Alice公布在她的网站上。我们可以假定有这样的合适的机制。
因此，使用公钥基础设施（PKI）可以满足我们之前所有的要求：
1. Bob可以用Alice的公钥通过解密密码文本来证明签名交易的真实性。
2. 只有Alice知道她的私钥，因此Alice不能否认交易的发生——她已经签名了。
3. 没有Alice的私钥，Bob或任何其他人都不能伪造或修改交易。

4. 注意第二条，Alice可以否认她是那个有争议的公钥——私钥对的真正所有者。
5. Alice和Bob只储存了签名交易的副本，消除了对中间人的需要。“神奇”的公钥密码和双方以物易物系统完美匹配。

<strong>余额 = Σ（收据）</strong>

随着公钥基础设施到位，Bob和Alice又完成了一些交易：Alice从Bob处得到另一张邮票，Bob从Alice那儿也挑了一张邮票。它们都按照与之前相同的步骤，生成签名交易并将它们附加到各自的分类账簿中。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cd10a65df.png" alt="图4" title="图4" />
记录是安全的，但有一个小问题：不清楚是否任何一方有未结余额。先前只有一个交易，很清楚是谁欠谁的（Alice欠Bob）以及欠了多少（一枚红色邮票），但是有多个交易以后，情况变得模糊起来。所有的邮票都是等值的吗？如果是，那么Alice有一个负余额。如果不是，那就谁也说不准了！为了解决这个问题，Alice和Bob达成一致如下：
1. 黄色邮票的价值是红色邮票的两倍。
2. 蓝色邮票和红色邮票等值。
最后为了确保他们新协议的安全性，他们用交易的相对值更新了每个交易，重新生成了分类账簿。新的账簿看起来像图5那样。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cd53cdf41.png" alt="图5" title="图5" />
这样，计算最终余额现在变成了一个简单的事，循环访问所有的交易，将适当的借贷记录应用于各方。最终结果是Alice欠Bob 2个“价值单位”。什么是“价值单位”？ 它是由Alice和Bob都同意的任意交换媒介，另外，由于“价值单位”并不耳熟能详，Alice和Bob同意将1个价值单位称为1个chroma（复数形式：chroms）。
上面这些看起来都是小事，但每一个参与者的余额都是分类账簿中所有收据的一个函数这一事实有重要的意义：任何人都可以计算大家的余额。不需要任何可靠的中间人，也不必对系统进行审计。任何人都可以遍历整个分类账簿，核实交易，计算出每一方的未结余额。

<strong>多方转移和验证</strong>

接下来，Bob无意中发现John有一枚邮票，他实在很喜欢。他告诉John他和Alice在使用的安全分类账簿，并问他是否愿意做个交易，Bob把Alice欠他的余额作为支付手段转移给John——即Bob从John那儿获得邮票，Alice之前欠Bob的金额将变成她欠John的。John同意了，但现在他们有个问题：Bob如何能以安全和可验证的方式把他的余额“转移”给John？经过一番协商，他们想出一个巧妙的计划（如图6所示）。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cd93d3fc7.png" alt="图6" title="图6" />
Bob按照与之前相同的步骤创建了一个新交易，不过他先计算出他想要转移的加密交易的SHA-256校验和（一个唯一的指纹），然后将校验和嵌入新收据中“是什么”一栏。事实上，他在将之前与Alice的交易与新的转移收据链接起来，这样就把它的价值转移给了John。
为了保持事物的简单性，我们假定所有的转移都会“消费掉”被转移交易的全部价值。要把这个系统扩展到使部分转移成为可能并不难，但此时没有必要考虑得那么复杂。
随着新交易到位，John为了安全起见，做了一个加密分类账簿的副本（现在有三个副本）并运行了一些检查来验证它的完整性：
1. John提取了Alice和Bob的公钥，验证前三个交易的真实性。
2. John证实了Bob转移的是一个“有效”交易：

2-1. 待转移交易的地址是Bob。
2-2. Bob此前没有把这个交易转移给任何其他人。
如果所有检查都通过了，他们就完成交易，我们可以通过遍历分类账簿来计算新的余额：Bob有一个净零数余额，Alice有2个chroma的借额，John有2个chroma的贷额（由Alice提供）。这样John现在就可以把他的新分类账簿拿给Alice并要求她支付，即使Alice没有出席交易，也没有问题：
1. Alice可以用Bob的公钥核实新转移交易的签名。
2. Alice可以核实转移的交易是对她和Bob一个有效交易的引用。
以上转移和验证过程是系统一个了不起的属性！注意要让它全部能工作，我们需要两个使能技术：一个是公钥基础设施的运用，使数字签名验证成为可能；另一个是收据账簿，使我们能够查看完整的交易记录以验证余额并链接先前的交易来进行转移。
John和Bob对这个巧妙的解决办法很满意，然后两人分头回家：Bob带着新邮票，John有了新的分类账簿。表面上看一切完美，但是他们刚刚把自己暴露在了一个极具挑战性的安全问题之下……你发现了吗？

<strong>重复消费和分布式一致性</strong>

在与John完成交易后不久，Bob意识到他们刚刚在他们的系统中引入了一个严重的漏洞，如果他迅速行动，就可以利用这个漏洞：Bob和John都更新了他们的分类账簿来包括新的交易，但是Alice和其他任何人都不知道交易已经发生。结果是，没有什么能阻止Bob接近网络中的其他人，给他们展示旧的账簿副本，而旧的账簿副本里没有他和John的交易！如果Bob说服他们进行交易，就像他和John做的那样，他就可以“重复消费”同一个交易，想进行多少次都可以！
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864ce37bd6c0.png" alt="图7" title="图7" />
当然，一旦多人拿着新的分类帐簿要求Alice支付，欺诈行为将被检测到，但这已经无济于事了——Bob已经带着战利品跑掉了！
只有两个参与者的时候，不可能受到双重消费攻击，因为要完成交易，你要验证并同时更新两个分类账簿，因此所有分类账簿始终保持同步。然而当我们再添加另外一个参与者时，我们就引入了各参与者之间账簿不完全和不一致的可能性，这就使双重消费成为可能。
在计算机科学语言中，双方分类账簿具有“强一致性”，超过两方的分类账簿则需要某种形式的分布式一致性以解决双重消费的问题。
这个问题最简单的可能的解决方案是要求分类账簿中列出的各方都必须在每个新交易发生时都在场，以便每个人可以同时更新他们的账簿。这个策略对小型的群组有效，但不能扩展到有大量参与者的情况。

<strong>分布式一致性网络的要求</strong>

我们来设想一下，我们想要将分类账簿扩展到全世界所有集邮者，这样任何人都可以用一种安全的方式交易他们喜欢的邮票。显然，由于地理位置，时区和其他限制，要求每个参与者在每个交易登记的时候都在场是不可能实现的。我们能建立一个不需要每个人都在场批准的系统吗？
1. 地理位置算不上一个真正的问题：我们可以把交流转移到线上。
2. 时区问题可以通过软件解决，我们不需要每个人手动更新分类账簿。相反，我们可以建立一个软件，它能在每个参与者的计算机上运行并代表他们自动接收、批准以及向分类账簿添加交易。
事实上，我们可以建立一个点对点（P2P）网络，负责分发新的交易并获得每个人的批准！ 但很可惜，说起来容易做起来难。例如，虽然P2P网络可以解决我们的地理位置和时区问题，但试想即便只有一个参与者离线，会出现什么情况？ 我们是不是要阻止所有交易，直到他们再次上线？
注意，“如何”构建P2P网络本身就是一个庞大的课题，构建这样一个网络的底层机制也远超出我们讨论的范围……我们把它作为一个练习留给读者。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cea815130.png" alt="图8" title="图8" />
原来分布式一致性的问题在计算机科学中已经被深入研究过，并且已经提出了一些有希望成功的解决方案。例如，两阶段提交（2PC）和Paxos都使这样一种机制成为可能，即我们只需要参与者的大多数法定人数（50％以上）接受就能安全地提交新的交易：只要大多数人已经接受交易，就能保证群组中剩下的人最终汇合在同一个交易历史。
即便如此，单单有2PC或Paxos是不够的。比如，在每天都有新参与者加入而其他人不预先通知就消失的情况下，2PC或Paxos如何知道我们P2P集邮者网络中的参与者总数？如果有一个先前的参与者离线，他们是临时还是永久离线？ 相似地，还有另一个我们必须考虑的更具挑战性的“Sybil攻击”：没有办法阻止一个恶意参与者创建许多档案，以在我们的P2P网络中获取不公平的投票权份额。
如果系统中的参与者数量是固定的，并且已经验证他们的身份真实有效（也就是说，这是一个可信网络），那么2PC和Paxos都会工作得很好。但我们不断变化的集邮者P2P网络并不是这样的情况。我们走进死胡同了吗？ 嗯，并不尽然……
这个问题有个明显的解决方案是从问题陈述中消除“分布的”部分。我们可以不建立一个P2P分布式系统，而是建立一个所有集邮者的全局注册表，记录他们的帐户信息，对他们进行验证并（尝试）确保没人能通过创建多个身份作弊，最重要的是，保证有一个共享的分类账簿副本！具体来说，我们可以建立一个网站，这些交易在网站上进行，网站将在它的集中式数据库里记录所有的交易，以此确保交易的完整性和正确排序。
以上是一个实用的解决方案，但我们得承认，它不尽如人意，因为它迫使我们失去了分类账簿系统点对点的性质。它将所有的信任置于一个单一的集中式系统，这就带来了一组全新的问题：什么是系统的正常运行时间，安全性和冗余；谁来维护系统，他们维护系统的动因是什么；谁有管理访问权限等等。集中式带来了它自己的一系列挑战。
让我们回顾一下在P2P设计中遇到的一些问题：
1. 确保每个参与者始终保持更新状态（强一致性系统）会产生很高的协调成本，影响可用性。如果单个点不可达，整个系统都无法提交新交易。
2. 在实践中，我们不知道P2P网络的全局状态：参与者人数，个体是暂时离线还是决定离开网络等。
3. 假设我们可以解决上述限制，系统仍然可能受到Sybil攻击，恶意用户可以伪造许多身份行使不公平的投票权。
不幸的是，解决上述所有限制是不可能的，除非我们放松一些要求： CAP定理告诉我们，我们的分布式系统不能有很强的一致性，可用性和分区容忍性。因此在实践中，我们的P2P系统必须在（更）弱一致性的假设下操作并克服它可能带来的影响：
1. 我们必须接受一些分类账簿不同步（至少是暂时不同步）；
2. 系统最终必须收敛于所有交易的整体序（线性一致性）；
3. 系统必须以可预测的方式解决分类账簿冲突；
4. 系统必须强制执行全局不变量——例如，没有重复消费；
5. 系统应该免受Sybil和类似的攻击。

<strong>保护网络免受Sybil攻击</strong>

在分布式系统中实现一致性，比如通过对每个参与者的投票计数，会出现很多关于各节点“投票权”的问题：允许谁参与，某些节点是否有更多的投票权，是否每个人都平等，以及我们如何强制执行这些规则？
为了保持简单，我们假定每个人的投票是平等的。第一步，我们可以要求每个参与者用私钥在他们的投票上签名，就像在他们的交易收据上签名一样，并将投票传播到他们的节点上——在投票上签名确保了别人不能代表他们投票。然后我们可以制定一个规则，只允许提交一票。如果同一个钥匙签名了多个投票，那么所有的投票都作废——已经下定决心！到目前为止还好，现在难的部分来了……
最开始我们怎么知道允许哪个特定的节点参与？如果只需要一个独特的私钥来签名投票，那么恶意用户可以简单地生成无限的新密钥充斥网络。根本问题是，当生成和使用伪造身份很便宜时，任何投票系统都很容易被颠覆。
为了解决这个问题，我们需要使提交投票的过程变得“昂贵”。提高生成新身份的成本，或者提交投票的过程必须产生足够高的成本。为了让问题更明确，我们来想几个现实世界的例子：
1. 你在当地政府选举中投票时，会要求你出示身份证件（例如护照），而伪造身份证件的成本很高（希望如此）。理论上，没什么能阻止你生成多个伪造的身份证件，但如果成本足够高（伪造的货币成本，被抓的风险等），那么运行Sybil攻击的成本将远大于其收益。
2. 或者，假设提交投票给你带来了一些其他成本（例如支付费用）。如果成本足够高，那么再次的，运行大规模Sybil攻击的障碍也增强了。
注意，上述例子都不能完全“解决”Sybil攻击，但它们也不需要被完全解决。只要我们将攻击的成本提高到大于成功破坏系统所能得到的值，那么系统就是安全的，会按照预期运行。
注意，我们所使用的“安全”的定义是很宽松的。系统仍然会受到操纵，确切的投票计数会受到影响，但关键是恶意参与者不能影响最终的结果。

<strong>参与所要求的工作量证明</strong>

任何用户都可以通过生成新的私钥—公钥对来轻易地（并且花很少的钱）在我们的P2P网络中生成新的“身份”。同样，任何用户都可以用他们的私钥签名投票并将其发送到P2P网络——这也很便宜，我们的收件箱中大量的垃圾邮件清楚地说明了这一点。 因此，提交新的投票很便宜，恶意用户可以轻易地用尽可能多的投票淹没网络。
但是，如果将以上其中一个步骤变得昂贵，使你不得不消耗更多的精力、时间或金钱，情况会怎样呢？ 这就是工作量证明背后的核心思想：
1. 工作量证明步骤对于发送者来说应该是“昂贵的”。
2. 他人验证工作量证明的步骤应该是“便宜的”。
这样一种方法有很多种可能的执行方式，但是为了达到我们的目的，我们可以再次使用之前遇到的密码散列函数的属性（如图9所示）。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864cf7da009d.png" alt="图9" title="图9" />
1. 很容易计算任何给定消息的散列值。
2. 生成具有给定散列值的消息很昂贵。

我们可以在我们的系统中施加一个新规则，要求每个签名投票必须具有以特定子串开始的散列值，即需要部分散列冲突，比如两个零的前缀。如果这看起来完全是任意的，那是因为它确实是任意的。跟着我的思路，我们通过几个步骤来看看这是如何生效的：
1. 我们假定一个有效的投票陈述是个简单的字符串："I vote for Bob" （“我投票给Bob”）。
2. 我们可以用同样的SHA-256算法来为我们的投票生成一个散列值。
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3305">代码1</a>
3. 生成的散列值无效因为它没有以我们要求的两个零子串开头。
4. 我们修改一下投票陈述，附加一个任意字符串再试一下：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3306">代码2</a>
5. 生成的散列值也不满足我们的条件，我们更新值，一次又一次地尝试…… 155次尝试之后我们最终得到了：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3307">代码3</a>
上述工作流程的关键属性是，每次我们修改完输入，加密散列函数（在这种情况下是SHA-256）的输出是完全不同的：当我们增加计数时，前一次尝试的散列值并不能透露下一次尝试所得到的散列值的任何信息。因此，生成有效投票并不仅仅是个“难的问题”，我们可以把它比喻成彩票，每次新尝试都会给你一个随机的输出。同时我们也可以通过更改所需前缀的长度来调整彩票的赔率：
1. SHA-256校验和中的每个字符都有16个可能的值： 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f.
2. 为了生成有两个零前缀的有效散列，发送者平均需要256 (16^2)次尝试。
3. 将要求变为5个零平均会需要1,000,000 (16^5) 多次尝试……关键是，我们可以轻易提高成本，让发送者找到一个有效散列需要耗费更多CPU周期。
我们可以在一个现代CPU上计算多少个SHA256校验和？它的成本取决于信息大小，CPU 架构和其他变量。如果你对此感到好奇，可以打开控制台，运行一个基准测试程序： $> openssl speed sha. 
最终结果是，生成有效投票对于发送者来说是“昂贵的”，但对于接收者验证仍然是微不足道的。接收者散列交易（一次运算）并且核实校验和中包含所需的散列冲突前缀……太好了，那么这对我们的P2P系统有什么用呢？上述工作证明机制使我们能够调整提交投票的成本，从而使破坏系统的总成本（即假冒足够多的有效投票来确保特定结果）高于攻击系统能够获得的价值。
注意，“生成消息的高成本”在很多其他环境中是个有用的属性。例如，垃圾邮件能够运作恰恰是因为生成信息特别便宜。如果我们可以提高发送电子邮件的成本，例如要求工作量证明签名，那么我们可以通过使成本高于利润来打破垃圾邮件的商业模式。

<strong>建立最小可行区块链</strong>

我们已经谈到了很多基础内容。在讨论区块链如何帮助我们构建安全的分布式账簿之前，我们来快速地扼要概述一下我们的网络设定，属性和待解决的挑战（如图10所示）：
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864d3e586cbf.png" alt="图10" title="图10" />
1. Alice和Bob完成交易并记录在各自的分类账簿中。 完成后，Bob有一个来自Alice的受公钥基础设施保障的借据。
2. Bob和John完成一个交易，他将Alice的收据转移给John。Bob和John都更新了账簿，但是Alice对交易尚不知情。 
2-1. 皆大欢喜的情景：John要求Alice偿还他的新借据，然后Alice得到Bob的公钥，核实了他的交易，如果交易有效，她向John支付所需金额。 
2-2. 不太欢乐的情景：Bob用没有记录他和John交易的旧账簿与Katy创建了一个重复消费交易，然后Katy和John同时出现在Alice家却发现只有一个人能得到报偿。
由于分布式账簿的“弱一致性”，重复消费是有可能的：Alice和Katy都不知道John和Bob之间的交易，这就使Bob利用了不一致性为自己谋利。有解决办法吗？如果网络很小，所有参与者都是已知的，那么我们可以要求每个交易在被认定为有效前必须被网络“接受”：
1. 全体一致：每当交易发生时，双方联系所有其他参与者，告知他们交易的有关内容，等所有参与者“同意”后才能提交交易。因此，所有分类账簿同时更新，不可能发生重复消费。
2. 法定人数一致：提高网络的处理速度和可用性（即如果有人离线，仍然可以处理交易），我们可以将上述全体一致的情况放宽到法定人数一致（整个网络的50％）。
对于参与者已知且已核实的小型网络，以上任何一个策略都能立即解决问题。然而，两种策略都不能扩展应用于更大型的动态网络，因为在任何时间点都无法得知参与者的总数和他们的身份：
1. 我们不知道要联系多少人来获得他们的同意。
2. 我们不知道要联系谁来获得他们的同意。
3. 我们不知道在与谁通话。
注意我们可以用任意通信手段来满足上述工作流程：当面，通过网络，信鸽通讯等等！ 
由于缺乏网络参与者的身份和对他们的全局认识，我们必须要放宽限制。虽然我们不能保证任意特定交易都有效，那并不能阻止我们对接受交易有效的可能性做出陈述：
1. 零确认交易：我们可以在不联系任何其他参与者的情况下接受交易。这是对交易付款方诚信的完全信任——相信他们不会重复消费。
2. N确认交易：我们可以联系网络中（已知）参与者的一部分子集，让他们验证我们的交易。 我们联系的节点越多，抓住企图欺诈我们的恶意方的可能性越大。
“N”的值多大为好？答案取决于要转移的金额以及你与对方的信任度和关系。如果金额很小，你可能愿意接受更高的风险级别，或者你会根据对另一方的了解程度来调整风险容忍度。或者，你会做些额外的工作，联系其他参与者验证你的交易。在任一情况下，处理交易速度（零确认是瞬时发生的），额外工作和交易无效的风险之间都存在一个折衷。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864d494d89aa.png" alt="图11" title="图11" />
到目前为止一切顺利。不过，有个额外的并发问题我们必须考虑：我们的系统依赖于来自其他节点的交易确认，但是没有什么能阻止恶意用户按照所需生成尽可能多的伪造身份（回想一下，我们系统中的“身份”仅仅是个公钥—私钥对，随便就能生成）来满足 Katy的验收标准。
Bob是否要进行攻击是一个简单的经济学问题：如果收益高于成本，他就会考虑实行攻击。相反，如果Katy可以使运行攻击的成本高于交易的价值，那么她应该是安全的（除非Bob和她有私仇或者愿意在交易上赔钱。但这不在考虑范围内）。为了让问题更明确，我们做出如下假设：
1. Bob转移10个chroma给Katy。
2. 生成伪造身份和交易响应的成本是0.001chroma：维持电脑运行的能源成本，支付网络连接等。
如果Katy要求1001次确认，对于Bob来说实行攻击就没有（经济）意义了。反之，我们可以为每次确认增加一个工作量证明要求，将每次有效响应的成本从0.001chroma增加到1chroma，即找到一个有效散列会占用CPU时间，转化为更高的能源费用。因此，Katy只要求11次确认就可以达到同样效果的安全保障。
注意，Katy每次请求确认也会导致一些成本：她必须耗费努力来发出请求，然后验证响应。此外，如果生成确认和验证的成本是一对一的，那么Katy将承担与交易价值相等的总成本来验证交易……当然，这没有任何经济意义。这就是为什么工作量证明的不对称很关键。
很好，问题解决了，对吧？在这个过程中，我们似乎……造成了另一个经济困境。我们的网络现在验证每个交易产生的成本与交易本身的价值相等甚至更高。虽然这是对恶意参与者的经济威慑，但合法参与者怎么会愿意为他人承担成本？理性的参与者根本不会，这毫无意义。

<strong>添加“区块”和交易费用激励</strong>

如果网络中的参与者必须承担成本来验证彼此的交易，那我们必须为他们提供经济激励。事实上，我们至少要抵消他们的成本，否则一个“空闲”参与者（任何没有提交自己交易的人）将会代表网络继续累积成本——这样是行不通的。还有一些我们需要解决的其他问题：
1. 如果验证交易的成本等于或高于交易价值本身（为了制止恶意参与者），那么总交易价值是净零，或负数！例如，Bob把10个chroma转移给Katy， Katy又花了10个chroma来补偿其他节点来验证交易，Katy很伤心。
2. Katy如何为确认进行支付？如果那是它自己的交易，就会有一个递归问题。
让我们从显而易见的问题开始：交易费用不能和交易本身的价值一样高。当然，Katy不必原封不动地把所有价值都用于确认交易（比如，她可以分配一半的价值用于确认），但这样又变成了一个利润问题：如果剩余利润（交易价值减去验证费）足够高，欺诈的动机仍然存在。相反，理想情况下，我们希望承担最低的交易费用，并仍然对恶意参与者有强大的威慑，有解决方案吗？
我们可以通过允许网络中的参与者一次性汇集和确认多个交易来激励他们，也就是对一个交易“区块”进行确认。这样做能让他们汇总交易费用，从而降低每个单独交易的验证成本。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864d5779c3e4.png" alt="图12" title="图12" />
一个区块仅仅是（一个或多个）有效交易的集合——把它想象成等同于物理分类账簿中的一个页面。反过来，每个区块包含对前一交易区块（上一页）的引用，整个分类账簿是区块的链接序列，也就是，区块链。想想上面的案例：
1. Alice和Bob生成新交易并公布到网络上。
2. Chris正在等着听新交易通知，每个交易通知包含发送方愿意支付于网络验证和确认交易的交易费用：
 2-1. 直到有直接的经济激励（交易费用总额大于他的成本）来完成必要工作来验证未决交易，Chris对未确认的交易进行汇总。
2-2. 一旦过了这个门槛，Chris首先验证每个未决交易，方法是核实所有的输入都不是重复消费。
2-3. 所有交易都被核实后，Chris在未决列表上再添加一个交易（上图中用绿色标识），将所发布交易的费用额转移给他自己。
2-4. Chris生成一个包含未决交易列表的区块，引用前一区块（使我们可以遍历区块并看到整个分类账簿），并执行工作量证明挑战，来生成符合网络既定规则的区块散列值，例如N个前导零的部分散列冲突。
2-5. 最后一旦Chris发现有效区块，他就分发给所有的其他参与者。
3. Alice和Bob在等着监听新的区块公告，寻找他们在列表中的交易：
3-1. Alice和Bob验证区块的完整性，也就是验证工作量证明和区块所包含的交易。
3-2. 如果区块有效，他们的交易在列表中，那么交易就被确认了！
我们在这里前进了一大步。以前我们的网络中只记录了一种类型——签名的交易。现在我们签名了交易和区块。前者由参与交易的个人生成，后者由有意通过验证和确认交易收费的各方生成。
另外请注意，上述方案需要系统中的最小交易量来维持个人创建区块的动机：交易越多，单个交易所需的费用越低。
Alice宣布了一个新的交易，并收到一个Chris确认它的有效区块。有了一个确认，那其余的呢？ 而且Chris（但愿）不是唯一一个受到激励来生成区块的参与者。如果其他人同时生成了另外一个区块，这两个区块哪个“有效”？

<strong>竞争以赢取交易费用</strong>

通过验证交易区块来引入汇总费用的能力，它了不起的部分在于，为网络中的新参与者创造了一个角色，他们有直接的经济激励来保障网络。你现在可以通过验证交易赚取利润，可以盈利的地方，竞争就随之而来，这只会加强网络——一个良性循环和聪明的社会工程！
即便如此，验证交易的竞争动机又产生了另一个有趣的困境：我们如何在分布式网络中协调区块生成工作？简短的回答，你可能已经猜到了，我们不会去协调。我们在系统中再额外添加一些规则，看看它们如何解决这个问题：
1. 允许任意数量的参与者参加（“竞赛”）创建有效区块。不需要协调，感兴趣的参与者反而会去找新的交易，决定是否想要以及何时想要尝试生成有效区块，领取交易费用。
2. 生成有效区块时，立即广播到网络中。
2-1. 其他节点检验区块的有效性（检查每个交易和区块本身的有效性），如果有效，就将其添加到他们的分类账簿中，然后最终重新广播到网络中的其他节点。
2-2. 添加以后，新的区块成为分类账簿的“最高档”。如果同一个节点也在生成区块，那么他们需要中止之前的工作重新开始：他们现在需要更新对最新区块的引用，并且从最新区块中包含的未确认列表里删除所有交易。
2-3. 完成以上步骤后，开始创建新区块，希望他们第一个发现下一有效区块，这样他们能够领取交易费。 
3. 重复以上步骤直到宇宙热寂。 
生成区块的所有参与者之间缺乏协调意味着网络中会有重复的工作，这也OK！虽然不能保证单个参与者获得特定区块，只要参与网络的预期价值（获得区块的概率乘以预期支出，减去成本）是正的，系统就可以自我维持。
注意，接下来要验证交易的节点之间没有一致性。每个参与者汇总自己的列表，运用不同策略来使预期收益最大化。此外，由于我们工作量证明函数（为区块SHA-256校验和找到一个部分散列冲突）的属性，增加获得区块概率的唯一方法是耗费更多的CPU周期。 
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864d692ec500.png" alt="图13" title="图13" />
还有一个需要应对的警告：两个节点可能会几乎同时发现一个有效区块，并开始在网络中传播——例如上表中的Kent和Chris。因此，一部分网络最终可能会接收Kent的区块作为最高区块，其余的会接受Chris的区块。现在怎么办？

<strong>解决链冲突</strong>

再次的，我们将采取一种不干涉的手段，让区块生成过程中的任意属性来解决冲突，虽然还有另外一个规则：如果检测到多个链，参与者应立即切换到最长的链，并在其顶部创建。我们来看看这在实践中如何工作：
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5864d6bd0d965.png" alt="图14" title="图14" />
1. 一些节点会开始在Kent的区块上建立新区块，其他人在Chris的区块上建立。
2. 在某一时刻，有人会发现新的区块，开始在网络中传播。
2-1. 其他节点接受新的区块时，与一个不同的最高区块合作的那部分网络将检测到现在有一个更长的链可替换，这意味着它们需要切换到更长的链上面。 
2-2. 作为被丢弃区块的一部分但尚未被确认的任何交易都被放在未决列表中，重新开始这个过程。 
2-3. 可能的情况是，竞争状况会持续多个区块，但最终某个分支会超过另一个，网络的其余部分将收敛到同一个最长的链上。
很好，我们现在有了一个策略来解决网络中不同链之间的冲突。具体来说，网络通过将交易记录在链接的区块列表中来允诺交易的线性化。但至关重要的是，它没有允诺个别区块可以“保证”任意一个交易的状态。想想上面的案例：
1. Alice将她的交易发送到网络。 
2. Chris生成一个确认她交易的有效区块。
但是链中有一个分叉，当稍后网络收敛在Kent的分支链上时，Chris的区块会被“移除”。因此，即使当Alice接收到一个有她交易的区块，她也不能确定这个区块将来不会被撤消！

<strong>没有哪个区块是“最后一个”</strong>

没有哪个区块是“最后一个”，永远不会有。 如果检测到更长的链，任何区块都可以被“撤消”。实际上，检测分叉相当快速，但总是存在出现替代链的可能。但是，我们唯一能说的是，特定区块在链中的位置“更深”，它被撤销的可能性就更小。因此，也没有哪个交易可以被视为“最终一个”，我们只能陈述它被撤销的概率。 
1. 0确认交易：不必等待任何包含交易的区块就可以进行交换。 
2. 1确认交易：最新的有效区块包含交易。 
3. N确认交易：有一个包含交易的有效区块，以及N-1个区块建立在那个有效区块上。 
如果愿意接受风险，你可以总是选择采用0确认交易：没有交易费用，也不必等待确认，不过你要对对方抱有极大的信任。
但如果你想降低风险，就要等待一个或多个区块建立在你交易所在的区块上。你等的时间越长，在包含你交易的区块上建立的区块越多，出现一个撤销你交易的替代链的可能性越低。
“撤消”指的是参与者使网络接受一个替代交易，将资金转移到除你以外的其他帐户上的情形——例如，你完成交易，移交组件，获得收据，但攻击者接着会注入一个交易，把同样的资金“双重消费”到另一帐户。
为什么区块链的长度可以很好地代表交易“安全性”？如果攻击者想要撤消一个特定交易，那么他需要建立一个链，链开始于列出交易区块的前一区块，然后建立一个由其他区块组成的、比网络当前所用链更长的链。因此，区块越深，通过创建新链来替换它所需要的计算量就越大。链条越长，运行攻击的代价就越昂贵。
在接受交易之前，你要等待多少个区块？它没有一个明确的数字，答案取决于网络的特性（生成每个区块的时间，交易和区块的传播延时，网络大小等）以及交易本身：它的价值，你对另一方的了解，你的风险预测等。

<strong>（最小可行）区块链的属性 </strong>

【个体交易的安全受公钥基础设施保障】
验证交易真实性：恶意方不能伪装成他人，代表他人签名交易。
交易真实性认证只与公钥—私钥对有关。不需要将密钥对与参与者其他数据链接的“强认证”。事实上，单个参与者可以生成和使用多个密钥对！从这一层面上看，网络允许匿名交易。 
不可否认性：事实发生后，参与方不能声称交易没有发生过。 
完整性：事实发生后，交易不能被修改。 

【交易一旦被创建，就被广播到点对点网络中】
交易一旦被创建，就被广播到点对点网络中

【一个或多个交易聚集在“区块”上】
 一个区块可以验证一个或多个交易并领取交易费用。 
这使得交易费用与每个交易的价值相比仍然是很低的。
有效区块必须有有效的工作量证明解决方案。
有效的工作量输出很难生成，但验证起来很便宜。 
工作量证明用于提高生成有效区块的成本，使运行对网络的攻击成本更高。 
任意节点都能用于生成有效区块，一旦有效区块生成，就被广播到网络中。
任意节点都能用于生成有效区块，一旦有效区块生成，就被广播到网络中。
每个区块有一个与前一有效区块之间的链接，使我们能够遍历网络中所有交易记录的完整历史。

【节点们寻找新的交易通知，将它们并入分类账簿中】
在区块中包含交易，作为交易“确认”，但这一事实本身不会将交易“最终化”。相反，我们以链的长度代表交易的“安全性”。每个参与者可以选择自己的风险承受水平，从0确认交易到等待任意数量的区块。 
所有上述规则和基础设施的组合提供了一个去中心化、点对点的区块链，用于实现签名交易排序的分布式一致性。说得有点多，我知道，但它也为一个大难题提供了巧妙的解决方法。区块链的单个部分（会计，密码技术，网络，工作量证明）并不新颖，但所有这些部分结合起来形成的新属性很值得关注。

原文链接：https://www.igvita.com/2014/05/05/minimum-viable-block-chain/
感谢llya授权《程序员》翻译本文
译者：汪晓明，朝夕网络创始人，前Beltal CTO。区块链是目前一个比较热门的新概念，蕴含了技术与金融两层概念。从技术角度来看，这是一个牺牲一致性效率且保证最终一致性的分布式数据库，当然这是比较片面的。从经济学的角度来看，这种容错能力很强的点对点网络，恰恰满足了共享经济的一个必须要求——低成本的可信环境。
本文以联盟链为例，描述了实践一个联盟链的基本过程。

<strong>总体思路</strong>

首先要确定这个区块链的类型，是公证型区块链还是价值型？
公证型区块链是指仅限一些关键数据自证、披露、防篡改等功能的区块链，通常是在价值型区块链中附带的功能，也可以单独扩展，用于公示公开等。价值型区块链是指可以进行资产所有权转移的一种记账账本。		
如果确定是价值型区块链，我们又需要确定目标区块链的总体定位：到底是一个普适的价值传输区块链，还是特定场景下的区块链？如果是特定场景下的区块链，我们通常推荐超级账本作为技术原型，如果是比较通用的价值区块链，我们推荐以太坊的思路。

<strong>业务场景的构建与初步分析</strong>

首先要明确的观点是，区块链不是万能的。很多场景其实是不需要区块链技术也能解决的。像跨境支付领域，区块链能很好的发挥是因为存在很多点对点的跨境机构有大量的支付清算需求，而又不希望中间机构参与，区块链是很好的选择。但是在一些集团内部，大型公司内部，区块链解决方案基本上远远不如传统的企业资源解决方案。

【需求痛点分析】
一般需求痛点在满足以下条件的时候，可以考虑使用区块链：
1. 存在一个不相互信任的P2P网络环境；
2. 节点之间是对等的，不存在一个绝对仲裁者；
3. 节点之间是博弈行为。
P2P网络可能包含输入和输出，当包含输入和输出时，区块链不再封闭。
对于某个节点一般有以下几种行为（包括但不限于）：
1. 不信任其他节点；
2. 保证自己的收益最大化；
3. 自私获取但不贡献资源。
针对以上情景的业务建模，需要针对具体的业务逻辑结合博弈论推导出满足自己需求的方案。

【非区块链技术能否解决】
案例1：
通常我们有不同的机构A、B、C，存在不对称的信息交换需求，即A、B、C分别具有部分数据，但三者组合到一起具有市场的全量数据。但是作为A，想知道B、C是否拥有自己数据集合中的某个点数据，根据这个结果来调整自己的购买策略。
案例2：
有不同的机构X、Y、Z，存在信息反馈的需求，当Z收到Y的服务时，会给Y一个信息反馈，这种反馈可能是信用评价，也可能只是响应反馈。总之这种反馈需要记录在案，X会根据Z的信息反馈结果调整自己的购买策略。当X购买服务时，同样会给Y一个反馈，Z也会收到反馈。
以上两个案例首先考虑使用非区块链是否可以解决：
针对案例1，敏感数据和私有数据是不会公开的，即使加密也不会被允许上传到区块链。所以产生了一个数据输入输出区块链的过程，该过程是区块链不可控制的。
那么使用传统的技术是否可以控制呢？貌似也不行，能够满足不暴露敏感数据的方案也只有HASH计算和同态加密。但是这两者都要求数据传输到指定位置。
通常我们会考虑使用零知识证明作为解决方案，然而具体的算法可能需要根据具体业务逻辑进行构建，结合简单智能合约，根据查询结果产生不同输出。
针对案例2，反馈信息容易被篡改，可刷单等问题是最大的，如何保证这种信息反馈是客观中立不可篡改的，可以结合区块链代币的币龄使交易具有方向性来防止作弊行为。

<strong>业务场景建模</strong>

针对第二节中的两个案例，我们接下来要进行建模，除去核心痛点，我们必然还有记账的需求，本质上任何案例中每个节点都既是服务方，也是客户方，那么怎么衡量自己贡献和索取了多少呢？
所以任何区块链平台上，必须是要有代币系统的，否则记账将非常困难。在业务场景建模过程中，我们主要关注如何使节点之间达成帕累托改进，而不是因为每个节点是自私行为，让区块链服务名存实亡。

<strong>开发路径</strong>

【区块链原型选取】
根据本文开头的叙述，如果是特定场景的区块链解决方案，建议Hyperledger fabric，当然搭建以太坊私有链也是可以的。
下面是一些以太坊和Fabric的比较：
以太坊与HyperLedger相同点：
1. 都是提供区块链业务实现的平台，业务实现都是通过智能合约来完成，以达到最大的灵活性和对底层的不修改。
1-1. 以太坊是：EVM虚拟机，Solidity合约语言；
1-2. HyperLedger是: Shim链码容器，用GO编写合约。 
2. 官方版本都使用GO语言实现。 
3. 因为都是提供第三方可编程能力，由于难度大，内部难免存在漏洞。对外则存在恶意程序攻击的威胁。尤其是在做为公有链时，威胁将会更大。上个月以太坊已有报合约solidity语言漏洞。
以太坊与HyperLedger不同点：
1. 以太坊只提供智能合约能力。也恰好吻合它的定位：智能合约和去中心化应用平台。对系统安全性或准入机制无底层无核心上的支持。而HyperLedger在吸收以太坊智能合约特点的同时，提供MemberShip及身份验证角色管理等模块，更贴近商业应用场景。 
2. 共识机制不同。由于共识的不一样，所以每秒可处理的交易量也不一样，以太坊是每秒千级别的处理量，而HyperLedger可以达到十万级别。 
3. 采用的技术实现思路上不一样。以太坊更多的是靠自己实现，自己造轮子，有点开发人员炫技的感觉，如自己提供合约语言solidity，自己实现EVM（这个可能是实际需要）。
表1是笔者曾经的一个私链项目中对两者的比较（私链考虑了Hydrachain的可行性）。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865bfeb4d573.jpg" alt="" title="表1" />
读者可以根据自己实际的TPS需求，进行共识的选型。
表2是不同共识的一些参考数据。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865c0289a23b.jpg" alt="表2" title="表2" />
当然，如果考虑自行开发，建议搭建基础比特币网络，做加法，更改共识算法，网络传送协议以及附加合约（可选）。
其实智能合约在一些场景中不是必选项，对用户来说，可靠方便实时是第一需求，如果针对特定的应用场景，将“合约”固化在区块链里面，也是一种可行的思路。
针对以上两种联盟链实现，笔者还想强调，并不是所有服务一定得是区块链的，笔者构想了一个通用的保护伞型结构，如比特币的侧链技术，主链提供基础账本服务，侧链提供特定场景服务，侧链上的应用可以是非区块链实现的，只需接口注册即可。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865ce6105111.jpg" alt="图1  保护伞结构" title="图1  保护伞结构" />

【交互接口设计】
在交互接口设计上，推荐使用目前业界通用的Json-RPC接口，扩展性和友好性兼备。
一般我们将接口分为两类：开放接口和账户接口。开放接口是指区块链本身的描述信息，是不需要认证的，而账户接口是需要账户认证的。

【基础账本设计】
基础账本设计包含以下两个问题：
首先是原型区块链是否已经满足需求？如果针对以太坊，基本上不需要改动基础账本，只需构建智能合约即可。如果以比特币体系为基础，则可能有较大的改动。
不满足需求时如何改动基础账本？这个其实要视账户模型而定，如果使用UTXO模式时，改动重点在如何嵌入模板交易体。如果使用Balance模式，那么则没有这个问题。

【业务扩展层设计】
业务扩展设计方面的内容比较复杂，篇幅问题这里也只是抛砖引玉提出两个问题：
1. 扩展层是外接区块链还是内置到区块链？
2. 如果包含数据输入，是否需要脱敏？脱敏后如何上链？
先想清楚这两个问题或许能帮你更好地规划业务扩展层的内容。

<strong>开发转变和难点</strong>

【开发思维的转变】
与传统网络服务不同的是，区块链开发不再以面向服务为主要关注点，而是面向账本和交易。
开发者面对的不再是以高可用高并发的应用程序为主要指标，而是切换到了面向用户，关注用户友好性和开发扩展性的终端程序开发。
所以高并发高性能不再是区块链终端的核心指标，安全性、可扩展性、友好性成了主要指标。
图2是一个适用于联盟链/私有链项目的工作流程。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865ce2dd01f2.jpg" alt="图2  适用于联盟链/私有链项目的工作流程" title="图2  适用于联盟链/私有链项目的工作流程" />

【开发难点】
目前来讲，区块链项目开发的难点有三个：
1. 开发人力资源储备不足
目前比较成熟的技术体系有比特币及衍生技术体系、以太坊、超级账本HyperLedger fabric、比特股Bitshares、瑞波Ripple和未来币NXT。其中前三个是最有影响力的区块链项目。比特币以及衍生技术多以C++语言进行开发；以太坊支持大部分主流语言，官方以Go为主，也有其他分支的项目如Rust语言的Parity钱包；超级账本目前以Go为主。
从目前上海地区的区块链从业人员来看，保守估计在400~500左右。按一半为开发人员计算，也才200多个，面对巨大的市场需求，人才是极度稀缺的。
由于C++目前仅在金融和游戏领域有部分需求，所以C++工程师不多，尤其是高水平的C++工程师就更少了。Go作为新兴语言，发展势头很猛，但是Go的生态也不如Java大。
如果从Java的角度看，如何把其生态利用起来，目前区块链还没有做到那个地步。
综合来看，区块链在技术方面与其他技术的结合还有待探索。
2. 区块链是交叉学科，需要各方面工程实践的经验。在实践方面，我们希望区块链从业人员同时了解技术和金融业务，这个对人员的素质要求比较高，相应的符合标准的人就更少了。
3. 关于对各个区块链技术体系理解的偏差，区块链技术和概念日新月异，闭门开发可能会走到死胡同，如何保持一部分精力更新知识体系，同时保证开发进度对开发人员是有较大挑战的。
区块链作为一门新兴的技术，涵盖了去中心化、去信任、共享经济、分布式计算、分布式存储等多方面的内容，考验着技术人员的学习和思考能力。在未来，区块链将同人工智能一起，会影响到普通人生活的方方面面。时常听人们谈起区块链，从2009年比特币诞生至今，各式各样的区块链系统或基于区块链的应用不断被开发出来，并被应用到大量的场景中，而区块链技术本身也在不停地变化和改进。
区块链又被称为分布式账本，与之对应的则是中心化账本，比如银行。与中心化账本不同的是，分布式账本依靠的是将账本数据冗余存储在所有参与节点中来保证账本的安全性。简单地说，区块链会用到三种底层技术：点对点网络、密码学和分布式一致性算法。而通常，区块链系统还会“免费附赠”一种被称为智能合约的功能。智能合约虽然不是区块链系统的必要组成部分，但由于区块链天生所具备的去中心化特点，使它可以很好地为智能合约提供可信的计算环境。
为了适应不同场景的需求，区块链系统在实际应用的过程中往往会需要进行各种改造，以满足特定业务的要求，比如身份认证、共识机制、密钥管理、吞吐量、响应时间、隐私保护、监管要求等。而实际应用区块链系统的公司往往没有进行这种改造的能力，于是市场上慢慢出现了一些用于定制专用区块链系统的框架，采用这些框架就可以很方便地定制出适用于企业自身业务需求的区块链系统。
本文将对目前市场上几个典型的区块链框架进行横向对比，看看它们都有哪些特点，以及它们之间到底有什么区别。为了保持对比的客观与公正，本文将只针对开源的区块链框架进行讨论。

<strong>各区块链架构的简单介绍</strong>

【比特币】
比特币（Bitcoin）源自中本聪（Satoshi Nakamoto）在2008年发表的一篇论文《比特币：一种点对点的电子现金系统》（Bitcoin：A Peer-to-PeerElectronic Cash System），文中描述了一种被他称为“比特币”的电子货币及其算法。在之后的几年里，比特币不断成长和成熟，而它的底层技术也逐渐被人们认识并抽象出来，这就是区块链技术。比特币作为区块链的鼻祖，在区块链的大家族中具有举足轻重的地位，基于比特币技术开发出的山寨币（Altcoins）的数量有如天上繁星，难以计数。
中本聪设计比特币的目的，就是希望能够实现一种完全基于点对点网络的电子现金系统，使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的中介机构。总结来说，他希望比特币能够实现以下这些设计目标：
1. 不需要中央机构就可以发行货币
2. 不需要中介机构就可以支付
3. 保持使用者匿名
4. 交易无法被撤销
从电子现金系统的角度来看，以上这些目标在比特币中基本都得到了实现，但是依然有一些技术问题有待解决，比如延展性攻击、区块容量限制、区块分叉、扩展性等。
在应用场景方面，目前大量的数字货币项目都是基于比特币架构来设计的，此外还有一些比较实际的应用案例，比如彩色币、tØ等。
彩色币（Coloredcoin），通过仔细跟踪一些特定比特币的来龙去脉，可以将它们与其他的比特币区分开来，这些特定的比特币就叫作彩色币。它们具有一些特殊的属性，从而具有与比特币面值无关的价值，利用彩色币的这种特性，开发者可以在比特币网络上创建其他的数字资产。彩色币本身就是比特币，存储和转移不需要第三方，可以利用已经存在的比特币基础网络。
tØ是比特币区块链在金融领域的应用，是美国在线零售商Overstock推出的基于区块链的私有和公有股权交易平台。

【以太坊】
以太坊（Ethereum）的目标是提供一个带有图灵完备语言的区块链，用这种语言可以创建合约来编写任意状态转换功能。用户只要简单地用几行代码来实现逻辑，就能够创建一个基于区块链的应用程序，并应用于货币以外的场景。以太坊的设计思想是不直接“支持”任何应用，但图灵完备的编程语言意味着理论上任意合约逻辑和任何类型的应用都可以被创建出来。总结来说，以太坊在比特币的功能之外，还有以下几个设计目标：
1. 图灵完备的合约语言
2. 内置的持久化状态存储
目前基于以太坊的合约项目已达到数百个，比较有名的有Augur、TheDAO、Digix、FirstBlood等。
Augur是一个去中心化的预测市场平台，基于以太坊区块链技术。用户可以用数字货币进行预测和下注，依靠群众的智慧来预判事件的发展结果，可以有效地消除对手方风险和服务器的中心化风险。
限于篇幅，基于以太坊智能合约平台的项目就不多介绍了。基于以太坊的代码进行改造的区块链项目也有不少，但几乎都是闭源项目，只能依靠一些公开的特性来推断，所以就不在本文展开讨论了。

【Fabric】
Fabric是由IBM和DAH主导开发的一个区块链框架，是超级帐本的项目成员之一。它的功能与以太坊类似，也是一个分布式的智能合约平台。但与以太坊和比特币不同的是，它从一开始就是一个框架，而不是一个公有链，也没有内置的代币（Token）。
超级账本（Hyperledger）是Linux基金会于2015年发起的推进区块链技术和标准的开源项目，加入成员包括：荷兰银行（ABN AMRO）、埃森哲（Accenture）等十几个不同利益体，目标是让成员共同合作，共建开放平台，满足来自多个不同行业各种用户案例，并简化业务流程。
作为一个区块链框架，Fabric采用了松耦合的设计，将共识机制、身份验证等组件模块化，使之在应用过程中可以方便地根据应用场景来选择相应的模块。除此之外，Fabric还采用了容器技术，将智能合约代码（Chaincode）放在Docker中运行，从而使智能合约可以用几乎任意的高级语言来编写。
以下是Fabric的一些设计目标：
1. 模块化设计，组件可替换
2. 运行于Docker的智能合约
目前已经有不少采用Fabric架构进行开发的概念验证（POC）项目在实施过程中，其中不乏一些金融机构做出的尝试，不过由于项目刚刚起步，还没有比较成熟的落地应用。

【Onchain DNA】
Onchain DNA（Onchain Distributed Networks Architecture），是由总部位于上海的区块链创业公司“分布科技”开发的区块链架构，可以同时支持公有链、联盟链、私有链等不同应用类型和场景，并快速与业务系统集成。分布科技同样也是超级账本的成员之一。
与以太坊、Fabric不同的是，Onchain DNA在系统底层实现了对多种数字资产的支持，用户可以直接在链上创建自己的资产类型，并用智能合约来控制它的发行和交易逻辑。对于绝大部分的区块链应用场景，数字资产是必不可少的，而为每一种数字资产都开发一套基于智能合约的业务流程非常浪费且低效。因此，由区块链底层提供直接的数字资产功能十分必要。而对于那些完全不需要数字资产的应用场景，同样可以基于Onchain DNA提供的智能合约功能来编写任意的自定义逻辑来实现。
Onchain DNA的设计目标主要有以下几点：
1. 多种数字资产的底层支持
2. 图灵完备的智能合约和持久化状态
3. 跨链互操作性
4. 交易的最终性
目前已有不少金融机构采用Onchain DNA架构来进行区块链概念验证产品的开发，如银行、券商、支付、登记结算机构等。除此之外，还有一些已经落地的区块链项目，如小蚁、法链等。
小蚁（Antshares）是一个定位于资产数字化的公有链，将实体世界的资产和权益进行数字化，通过点对点网络进行登记发行、转让交易、清算交割等金融业务的去中心化网络协议。它采用社区化开发的模式，在架构上与Onchain DNA保持一致，从而可以与任何基于Onchain DNA的区块链系统发生跨链互操作。
法链是全球第一个大规模商用的法律存证区块链，一个底层基于Onchain DNA区块链技术，并由多个机构参与建立和运营的证据记录和保存系统。该系统没有中心控制点，且数据一旦录入，单个机构或节点无法篡改，从而满足司法存证的要求。

【Corda】
Corda是由一家总部位于纽约的区块链创业公司R3CEV开发的，由其发起的R3区块链联盟，至今已吸引了数十家巨头银行的参与，其中包括富国银行、美国银行、纽约梅隆银行、花旗银行、德国商业银行、德意志银行、汇丰银行、三菱UFJ金融集团、摩根士丹利、澳大利亚国民银行、加拿大皇家银行、瑞典北欧斯安银行（SEB）、法国兴业银行等。从R3成员的组成上也可以看出，Corda是一款专门用于银行与银行间业务的技术架构。尽管R3声称Corda不是区块链，但它具备区块链的一些重要特性。
Corda由Java和Kotlin开发，并在其各项功能中充分依赖于Java，比如智能合约、数据访问接口等。Corda的设计目标主要是：
1. 没有全局账本
2. 由公证人（Notaries）来解决交易的多重支付问题
3. 只有交易的参与者和公证人才能看到交易
为此，Corda的所有交易都不会向全网进行广播，而且所有的节点都是直接通信，没有P2P网络。这一点导致了其网络规模会被限制在一个较小的规模内，无法形成大规模的联盟链，适用的业务场景比较狭窄。

<strong>技术对比</strong>

接下来，我们将针对前文中所提到的这些区块链框架进行一系列的技术对比，并从多个维度展开讨论它们的区别与相似之处。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865d716bb16b.jpg" alt="表1" title="表1" />

【数字资产】
区块链的内置代币通常是一种经济激励模型和防止垃圾交易的手段。比特币天生就有且只有一种内置代币，所以在比特币系统中所有的“交易”本质上都是转账行为，除非通过外部的协议层来给比特币增加额外的数字资产。
以太坊和Onchain DNA具有内置代币，它们的作用除了以上提到的经济激励和防止垃圾交易之外，还为系统内置功能提供了一个收费的渠道。比如以太坊的智能合约运行需要消耗GAS，而Onchain DNA的数字资产创建也需要消耗一定的代币（可选）。
以太坊和Fabric没有内置的多种数字资产支持，而是通过智能合约来实现相应的功能。这种方式的好处在于，系统设计可以做到非常简洁，而且资产的行为可以任意指定，自由度极高。然而这样的设计也会带来一系列的负面影响，比如所有的资产创建者不得不自己编写重复的业务逻辑，而用户也没有办法通过统一的方式去操作自己的资产。
相比之下，Onchain DNA和Corda采用了在底层支持多种数字资产的方式，让资产创建者可以方便地创建自己的资产类型，而用户也可以在同一个客户端中管理所有的资产。对于逻辑更加复杂一点的业务场景来说，他们同样可以利用智能合约来强化资产的功能，或者创建一种与资产无关的业务逻辑。

【账户系统】
UTXO（Unspent Transaction Output）是这样一种机制：每一枚数字货币都会被登记在一个账户的所有权之下，一枚数字货币有两种状态，即要么还没有被花费，要么已经被花费。当需要使用一枚数字货币的时候，就将它的状态标记为已经花费，并创造一枚新的与之等额的数字货币，将它的所有权登记到新的账户之下。在这个过程中，被标记为已花费的数字货币就被称为交易的输入，而创造出来的新的数字货币被称为交易的输出，在一笔交易中，可以包含多个输入和多个输出，但是输入之和与输出之和必须相等。计算一个账户的余额时，只要将所有登记在该账户下的数字货币的面额相加即可。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865d78913fc0.jpg" alt="表2" title="表2" />
比特币和Corda就采用了UTXO这样一种账户机制，而以太坊则采用了更加直观的余额机制：每个账户都有一个状态，状态中直接记录了账户当前的余额，转账的逻辑就是从一个账户中减去一部分金额，并在另一个账户中加上相应的金额，减去的部分和加上的部分必须相等。Onchain DNA在账户机制上同时兼容这两种模式。
那么UTXO模式和余额模式，究竟有什么区别呢？UTXO最大的好处就是，基于UTXO的交易可以并行验证且任意排序，因为所有的UTXO之间都是没有关联的，这对区块链未来的扩展性有很大的帮助，而基于余额的设计就没有这个优势了。反过来，余额设计的优点是设计思想非常简洁和直观，便于程序实现，特别是在智能合约中，要处理UTXO的状态是非常困难的。这也是为什么以智能合约为主要功能的以太坊选择余额设计的原因，而比特币、OnchainDNA、Corda这些以数字资产为核心的架构则更倾向于UTXO设计。
关于身份认证，比特币和以太坊基本没有身份认证的设计，原因很简单，因为这两者的设计思想都是强调隐私和匿名，反对监管和中心化，而身份认证就势必要引入一些中心或者弱化的中心机构。
Fabric、Onchain DNA和Corda不约而同地选择了采用数字证书来对用户身份进行认证，原因在于这三者都有应用于现有金融系统的设计目标，而金融系统必然要考虑合规化并接受监管，此外现有的金融系统已经大范围地采用数字证书方案，这样便可以和区块链系统快速集成。
【共识机制】
共识机制是分布式系统的核心算法，因为分布式系统的数据分散在各个参与节点中，这些分散的数据必须通过一种算法来保持一致性，否则系统将无法正常工作。与传统的分布式系统不同，区块链是一个去中心化的系统，并且可能会承载大量的金融资产，所以它可能会面临大量的拜占庭故障而非一般性故障，而中心化的分布式系统则很少遇到拜占庭故障。因此，区块链的共识机制与传统的分布式系统存在较大的差异。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865d7d1d611b.jpg" alt="表3" title="表3" />
比特币和以太坊采用了工作量证明（Proof-of-Work）机制来保证账本数据的一致性。工作量证明同时也是一种代币分发机制，它通过经济激励的方式来鼓励节点参与区块的构造过程，节点在构造区块的时候需要穷举一个随机数以使得区块符合规定的难度要求，一旦区块链出现分叉，诚实的节点将选择工作量较大的链条，而抛弃工作量较小的。由于假设所有节点都是逐利的，而选择工作量较小的链条就会使自己获得的激励无效，所以最终所有的节点都会是诚实的，从而使每个节点的区块链数据都保持一致。
为了维护这样一个工作量证明机制的区块链，需要全网具备较大规模的算力支撑来保证网络的安全性，否则账本数据就有可能被篡改。此外，即使维持较大的算力来保护网络，工作量证明也无法从根本上保证交易的最终性，比如比特币就经常产生孤立区块（Orphaned Block），而包含在孤立区块中的交易就有可能被撤销。因此比特币通常要求用户等待6个区块的确认，即1小时左右的时间，才能在一个可接受的概率上认为交易已经最终完成，而这个概率也并非是最终性的——你永远也不知道暗中是否有一个远超过全网的庞大算力正在试图撤销以前的交易。而为了维护庞大算力而支出的电力成本也是相当可观，因此，以太坊已经在设计从工作量证明机制切换到其他共识机制上的方案。
Fabric和Onchain DNA都设计了基于拜占庭容错（Byzantine Fault Tolerance）模型的共识机制。节点被分为普通节点和记账节点（Validating Peer），只有记账节点才会参与到区块的构造过程，这种角色的分离使得算法的设计者有机会将运行共识算法的节点数量限定在一个可控的规模内。
拜占庭容错模型对网络中的节点做出了假设和要求：如果共识中有f个节点会出现拜占庭故障，那么至少需要3f+1个节点参与共识才能避免网络出现分叉。在这个模型下，每个区块的构造过程都需要至少2f+1个节点的参与才能够完成，而不像工作量证明机制下每个节点都独立构造区块。一旦区块被构造出来，它就无法被撤销，因为2f+1个诚实的记账节点不会在同一高度对两个不同的区块进行签名认证。
相比较而言，工作量证明机制提供了极高的灵活性和可用性，因为每个节点都独立构造区块而几乎不需要其他节点的参与，节点可以随时加入或者退出网络，即使全网只剩下一个节点，网络还是可以继续工作，但是相应的它也失去了交易的最终性；而拜占庭容错的机制则与之相反，牺牲了一定的灵活性和可用性，记账节点必须在线提供服务而不能退出网络，一旦出现1/3的记账节点停机，那么网络将变得不可用，但它保证了交易的最终性。

【智能合约】
智能合约是1994年由密码学家尼克萨博（Nick Szabo）首次提出的理念，几乎与互联网同龄。智能合约是指能够自动执行合约条款的计算机程序，在比特币出现以前，因为不存在安全可靠的执行环境，智能合约一直不能够应用到现实中。区块链由于其去中心化、公开透明等特性，天生就可以为智能合约提供可信的执行环境。所以，新型的区块链框架几乎都会内置智能合约的功能。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865dc4563ed5.jpg" alt="表4" title="表4" />
比特币内置了一套基于栈的脚本执行引擎，可以运行一种独有的脚本代码，用于对交易进行简单的有效性验证，比如签名验证和多重签名验证等。这套脚本语言被有意设计成非图灵完备的，足够简单却也足以应对货币转账的各种需求。
以太坊是首个以图灵完备智能合约为主要功能的区块链，用户可以在以太坊的平台上创建自己的合约，而合约的内容可以包含货币转账在内的任意逻辑。合约使用一种名为Solidity的语言来编写，它是以太坊团队开发的专门用于编写智能合约的一种高级语言，语法类似JavaScript，最终被编译成字节码并运行在EVM（Ethereum Virtual Machine）之中。EVM提供了堆栈、内存、存储器等虚拟硬件，以及一套专用的指令集，所有的代码都在沙盒中运行。它提供了合约间相互调用的能力，甚至可以在运行时动态加载其它合约的代码来执行。这种能力使得以太坊的合约具有非常高的灵活性，但也可能会使合约的功能具有不确定性。
与以太坊自己动手开发语言、虚拟机的思路不同，Fabric选择了使用现有的容器技术来支持智能合约功能。Fabric的智能合约理论上可以用任何语言来编写，这一点对开发者相当友好，他们将无需学习新的语言，并且可以复用现有的业务代码和丰富的开发库，并使用自己熟悉的开发工具。相对的，采用Docker的智能合约架构也有大量的问题：首先，它很难对智能合约的执行流程进行控制，从而无法对其功能进行限制；其次，它无法对合约运行所消耗的计算资源进行精确的评估；此外，运行Docker相对而言是极其耗费资源的操作，这就使得难以在移动设备上运行合约；最后，不同节点的硬件配置、合约引用的开发库等，都有可能会使合约的行为具有很强的不确定性。
Onchain DNA采用了AVM（Antshares Virtual Machine）作为其智能合约功能的底层支持。AVM是一个微核心的、平台无关的智能合约执行环境，它提供了一套包含堆栈操作、流程控制、逻辑运算、算数运算、密码学运算、字符串操作、数组操作的指令集，在硬件方面，它只提供了两个计算堆栈。不过，由于它允许区块链的实现者创建自己的虚拟硬件，并以接口的形式开放给智能合约来使用，使得合约可以在运行时取得平台相关的数据、持久化存储以及访问互联网等。虽然这也有可能会使合约的行为具有不确定性，但区块链的实现者可以通过合理编写虚拟硬件来消除这种不确定性。不过，由于目前尚无与AVM配套的编译器和开发环境，这使得基于AVM进行智能合约开发变得相当困难，开发者不得不使用一种类似汇编的语法来进行合约编写，需要较高的技术能力。
Corda的智能合约功能与其自身一样，都是基于JVM（Java Virtual Machine）的。因此，你可以使用任何与JVM兼容的语言来进行开发，比如Java、Kotlin等。不过，它对JVM进行了一定的改造，使得在其上运行的合约脚本具备确定性。开发的过程大致是这样的：使用Java创建一个实现Contract接口的类（Class），并提供一个名为verify的函数（Function）用于对交易进行验证，该函数接受当前的交易作为参数，如果交易验证失败，则抛出异常（Exception），没有异常就表示验证通过。Corda使用JPA（Java Persistence Architecture）来提供持久化功能，支持SQL语句和常用的数据库，不过需要安装相应的插件，并且由于数据仅存放在合约执行者的节点，因此无法进行全局的持久化存储。

【扩展性】
区块链的数据结构通常是只能追加记录，而不能修改或删除记录，它真实地记录下完整的历史数据，使得新加入的节点有能力对全网的完整交易历史进行验证，而无需信任其它节点。这种特性带来了去中心化的便利性，但也影响了区块链系统的扩展性，因为区块会无休止地增长，直到塞满整个硬盘。所以有必要提供一种空间回收的机制来应对不断增长的数据。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/5865dc89b5cac.jpg" alt="表5" title="表5" />
比特币提出了使用默克尔树（Merkle tree）来存放交易散列的方式，当需要回收硬盘空间时，只需将老旧的交易从默克尔树中剔除即可。一个不含交易信息的区块头大小仅有80字节。按照比特币区块生成的速率为每10分钟一个，那么每一年产生的数据约为4.2MB，即使将全部的区块头存储于内存之中都不是问题。
以太坊、Fabric和Onchain DNA在比特币区块压缩的基础上，又采用了状态快照的方式来节约硬盘空间。具体来说，就是在区块头的结构中不但记录了当前区块所有交易的根散列，还记录了当前区块及过去所有区块中的状态根散列。这些状态包括所有的UTXO、账户余额、合约存储等，所以节点只需要保留最新的区块和完整的状态信息即可。
扩展性的另一个重要指标是交易的吞吐量。决定吞吐量的因素有很多种，如网络结构、加密算法、共识机制等，但最重要的还是交易是否可以被并行验证。如果交易可以被并行验证，那么未来就可以通过简单地增加CPU数量来提高吞吐量。
基于UTXO系统的比特币可以很容易地对交易进行并行验证，因为UTXO之间是没有关联的，对任何一个UTXO的状态改变都可以独立进行且与顺序无关；而基于余额的账户系统则不那么容易实现并行，因为可能会同时发生多笔交易对同一个账户进行资产操作，需要进行一些额外的步骤来处理。举个例子，假设账户中的余额为10元，有两笔针对该账户的交易同时发生，第一笔交易在账户中+5元，而第二笔交易在账户中-11元。那么如果先执行第一笔交易，则两笔都能成功，最终余额为4元；如果先执行第二笔交易，那么它会因余额不足而失败，只有第一笔交易会成功，最终余额为15元。
而对交易的并行验证起到决定性作用的，是智能合约是否具备状态持久化的能力。如果一组合约都是无状态的，那么它们就可以按任意的顺序被执行，不会产生任何副作用；相反，如果合约可以对一组状态产生影响，那么按不同的顺序来执行合约产生的结果也会不同。举个例子，一个计算存款利息的合约，它具有两个子功能：存款和利息结算。假设账户中有100元，利率为10%，现在同时发生了两笔交易，第一笔交易的内容是存入100元，第二笔交易的内容是结算利息。假如第一笔交易先执行，那么最终账户的余额是：100+100）*110%=220元；如果第二笔交易先执行，那么账户余额将是：100*110%+100=210元。由此可见，具备状态持久化能力的智能合约是顺序相关的，因此难以并发验证，特别是如果合约之间还可以相互调用的话，情况将会更加复杂。
目前Fabric没有提出什么好的办法来解决这个问题；而Corda则没有这个问题，因为它的交易本身就不会向全网进行广播，所以只要交易参与者和公证人可以验证即可。以太坊和Onchain DNA的方法都是分区，即将各个合约分到不同的逻辑区中，每个区中的合约都顺序执行，而不同的区之间并行执行。以太坊将合约地址的首个字节作为分区依据，由此产生了256个分区，每个合约都在自己的分区中运行，且只能调用与自己相同分区的合约。但这种做法实际上并不能有效地解决问题，因为总有一些通用的底层合约因为被广泛使用，而把大多数的调用者合约聚集在同一个分区中。
Onchain DNA将合约分为功能合约（Function code）和应用合约（Applicationcode）。其中功能合约专门用于提供可复用的功能函数，被其它合约调用，且必须被声明为无状态，这一点消除了绝大部分的合约聚集现象；而只有应用合约可以保存自己的状态，所以在执行应用合约时，对其采用动态分区方案：在合约被执行之前，会先计算出它们的调用树，并将调用树有交集的合约放在同一个分区中执行。

<strong>独有特性</strong>

【幽灵协议】
幽灵协议是以太坊对现有POW算法的改进，它提出的动机是当前快速确认的区块链因为区块的高作废率而受到的低安全性困扰。因为区块需要花一定时间扩散至全网，如果矿工A挖出了一个区块然后矿工B碰巧在A的区块传播至B之前挖出了另外一个区块，矿工B的区块就会作废并且没有对网络安全作出贡献。如果A是一个拥有全网30%算力的矿池而B拥有10%的算力，A将面临70%的时间都在产生作废区块的风险而B在90%的时间里都在产生作废区块。通过在计算哪条链“最长”的时候把废区块也包含进来，幽灵协议解决了降低网络安全性的第一个问题；这就是说，不仅一个区块的父区块和更早的祖先块，祖先块的作废的后代区块（以太坊术语中称之为“叔区块”）也被加进来以计算哪一个区块拥有最大的工作量证明。以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励，把它们纳入计算的“侄子区块”将获得奖励的12.5%。计算表明，带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%。

【国密算法】
国密算法是由中国国家密码管理局制定的一系列商用密码学算法，其中包括了对称加密算法SM1，椭圆曲线非对称加密算法SM2，杂凑算法SM3等。通常区块链在使用密码学算法时会采用国际标准，如AES、ECDSA、SHA2等。而国内的金融机构在选用密码学方案的时候，通常会考虑国密算法。Onchain DNA提供了可选的密码学模块，针对不同的应用场景可以选择不同密码学标准，解决了安全性和政策性风险。

【跨链互操作】
目前，区块链技术正处于百花齐放、百家争鸣的时代，各种不同的区块链纷纷涌现出来，区块链之间的互操作性成为了一个非常重要而又迫切的需求。企业用户可能需要在不同的链之间进行业务迁移；普通用户可能需要在不同的链之间进行资产交换；央行的数字法币可能会需要在各个区块链上流通等。Onchain DNA提供了一种跨链互操作协议，通过这种跨链协议，用户可以跨越不同的区块链进行资产交易、合约执行等操作，并保证该操作在各个区块链上的事务一致性。

【无链结构】
正如Corda在白皮书中所宣称的那样，它没有链式结构，交易也不向全网进行广播，而只在交易的参与者和公证人之间发送。因此，数据只有“需要访问的人”才能访问，避免了隐私泄露的问题。由于没有全局的链式结构，每个节点只存放和自己有关的交易，而无需存放全网的所有交易，大大的节省了空间。

<strong>总结</strong>

本文从多个维度比较并讨论了当前各个区块链框架的特点和功能，并阐述了它们在各方面的优缺点，以及在应用领域上的适用性和局限性。
比特币虽然是区块链技术的原型，具有非常重要的地位，但由于其技术架构的局限性，如挖矿、非图灵完备等，很难应用到复杂的业务场景中去，但非常适合用于货币发行。
以太坊虽然也采用挖矿的形式，但其幽灵协议提高了挖矿效率，新的共识算法也在开发中。以太坊还开发了较多基于密码学的隐私保护方案，比如环签名混币方案，非常适合于创建去中心化自治组织(Decentralized Autonomous Organization)。
Fabric和Onchain DNA的定位都是企业级区块链解决方案，适合用于定制各种特定业务的联盟链，包括金融领域的应用场景。区别在于Fabric以智能合约为导向，而Onchain DNA则以数字资产为导向；前者更适合开发复杂的自定义业务流程，而后者则更适合于构建以数字资产为核心的金融业务系统或权益登记流转系统，且具有较强的扩展性。
Corda的定位是用于银行间业务的“分布式数据库”，它摒弃了区块和链式结构，更好地把参与者的业务数据区隔开来；但引入了公证人的角色，网络结构较为固定不具灵活性和扩展性，且与现有的银行体系的运作方式差别不大。如果说比特币是对传统货币的一种颠覆，那么比特币的基础技术——区块链则是对传统编程范式的一种颠覆。区块链技术被看作是一次Paradigm Shift。也许很多人对 “颠覆”这种说法不以为然，因为现在这个词已经被用滥了（如今哪个好一点儿的词没有被用滥呢？），但是明眼人在匆忙做出“这又是个噱头”这样的结论之前会谨慎地去了解它背后的东西。这篇文章的目的就是为程序员介绍区块链的独特技术，以及这些技术如何运用到项目或者产品的开发过程中。即使你不想进入全新的区块链应用开发大潮，你也会发现其底层技术对平日的应用开发有不少启发和借鉴作用。一个新技术的诞生有它顺应时代的合理性（黑格尔语“存在就是合理的”）。作为程序员我们应该去了解它的合理性所在之处，取而用之。我们不一定非要用新技术去颠覆一个老应用，但可以用新技术去重塑一个老应用。
本篇主要讨论区块链在三个方面的独特性：去中心和去中介、隐私保护、时间戳。

<strong>去中心和去中介</strong>

1994年凯文 · 凯利（国内称KK）出版了一本预言式的巨著《失控》，书中充满了关于智慧生命及其社会进化机制的真知灼见。书中提到的很多概念，比如云计算、物联网、网络社区等，在二十多年后的今天已经成为普遍事实。“去中心化”是凯文 · 凯利在书中提出的“九律”中的一条。一个去中心化的系统，没有一个中央的、至上而下的控制主体，而完全是由大量相互联结看似无组织的小个体构成，这些个体有一定的独立性，可以相互作用，它们自发地形成一个整体以后，由量变引起质变，结果整体的能力、智慧、适应性和灵活性，都大大超过了个体的简单相加。这样的去中心化系统生命力极强，遭到破坏可以自我修复，因而很难被完全摧毁。
互联网就是一个典型去中心化的例子，极强的适应性和抗破坏性是互联网的根本。不过如今的互联网却有了中心化的趋势。中心化的后果见仁见智，对崇尚多种选择的人来说，中心化代表着选择自由的丧失，服务质量的下降，活力的倒退和创新的萎缩。微博做为新一代互联网媒体的翘楚，它的兴起、没落以及再次复兴，从内容的产生和传播来说，就是一个从一开始的去中心化，到由大V们控制的中心化，再到去中心化的历程。总之，只有那些赋予其中每个个体充分发展的自由的系统，那些抗拒中心化趋势的系统，才是生机勃勃、有创新力、能够不断进化的系统。
站在2016-2017年之交，智能机器时代似乎离我们不远了。芯片、存储、网络、移动、物联网技术，都极大增强了各种网络终端（edge）的能力，无论这些终端是人、手机、汽车、机器人，或是其他设备。以前由于存储、网络或者计算能力等限制而选择中心化的应用程序设计，现在的程序员则有更大的自由去选择一种去中心化的设计。去中心化的系统更加灵活，更具适应性，更有活力。
另一方面，现实社会中的各种交易活动，由于交易双方缺乏信任、信息不对称、搜寻成本、匹配效率、交易费用等因素，需要有交易双方共同信任的中介参与。比如银行间的跨境支付，中间需要通过SWIFT网络和代理银行，而不能直接进行点对点交易。中介的产生源自于降低交易成本的目的，但是随着新技术的出现和普及，双方直接交易成为可能，而且成本更低。在这样的情况下中介变得多余了，交易双方通过去中介化来降低交易成本。
去中心和去中介有多种不同层次，可以体现在业务模式、业务数据的产生和传播、应用系统的架构、应用系统的开发、运行、维护、升级等方面。比特币和区块链是一种比较彻底的去中心和去中介应用，它包含以下几种去中心和去中介技术：
1. 点对点网络（P2P network）。点对点网络并不是什么新概念，网上的很多文件共享和视频直播服务就是用P2P网络协议实现的。P2P是对等网络，网络中每个节点的地位相当，没有任何节点处于中央控制的地位，也没有任何节点扮演交易中介的角色；每个节点既是Server，又是Client；节点可以选择随时加入，随时退出；节点可以选择运行所有的功能（Full node），也可以选择运行部分的功能；节点越多，整个系统的运算能力越强，数据安全性越高，抗破坏能力越强。
2. 去中心化数据库，这就是区块链，例如Bitcoin的分布式总帐。
3. 去中心化应用 (Decentralized App，简称 DApp)， 例如在Ethereum上运行的智能合约应用。
4. 共识算法。无中心、无中介、无需相互信任的对等网络的节点间需要协调一种共识算法，以便共同维护一个统一的分布式数据库，以及协同工作以保障整个系统的安全性和适应性。有多种共识算法，包括：PoW–Proof of Work工作量证明、PoS – Proof of Stake权益证明、DPoS–Delegated Proof of Stake授权权益证明、PBFT–Practical Byzantine Fault Tolerance实用拜占庭容错、PoET–Proof of Elapsed Time流逝时间量证明等。
作为一个程序员或者架构师，这些思路和技术有什么帮助呢？你的应用需要去中心或者去中介吗？你的下一个应用需要采用去中心化的架构吗？设计去中心化的架构需要作哪些改变？需要哪些基础设施？在时下这股区块链的淘金热里，已经有很多创业公司准备颠覆传统的中心化应用。几乎所有的应用，都开始有相应的基于区块链技术的去中心化版本。如果你认为目前没有必要或者不可能去中心化，未雨绸缪总是不会错的。

<strong>隐私保护</strong>

个人隐私信息泄露在中国是一个非常严重的现象。盗取、贩卖个人信息已经有完整的黑市产业链，部分互联网征信和数据公司，从黑市上购买数据，甚至雇佣黑客盗取数据。互联网用户普遍意识到个人隐私信息的重要，对隐私保护的要求会更高。程序员有责任从技术上加强个人隐私的保护。在传统的应用架构设计中，隐私保护或者安全性设计的优先级并不是很高，现在这种情况必须有所改变，架构师需要提升隐私保护设计的优先级。
区块链应用领域采用了很多密码学的技术，例如哈希算法、加密算法、公钥密码学、默克尔树、和零身份证明。Bitcoin在保护用户身份方面，使用哈希过的公钥作为个人账号，这样在交易时隐藏了个人信息。另外，个人账号可以设计成一次性的，每次交易都使用新账号，这样就很难通过追踪某个账号的交易来推测用户身份。Bitcoin的总帐是公开的，上面每笔交易记录包含付费账号、收费账号以及转账金额。如果觉得这样的隐私保护还不够，另一个数字货币Zcash在Bitcoin之上增加了一些协议，将付费账号、收费账号以及转账金额都隐藏了起来，采用的方法仍然是加密、哈希、默克尔树和零知识证明。
尽管比特币出自于一群无政府主义者之手，但他们秉承的一些诸如保护个人隐私的信念，在这个信息泛滥的互联网时代还是非常可取的。你的应用是否收集了超越应用需要的个人信息？（保护隐私的最好办法就是不收集它们）在处理交易时，是否可以传递尽可能少的个人身份信息？或者使用一次性账号？在日志中是否可以记录尽可能少的个人身份信息？或者完全不需记录？缓存数据库中的个人信息是否安全？消息传递时不仅采用Session Key加密，是否还可以采用Message Key？如今，哈希算法、公钥加密，默克尔树，这些加密技术唾手可得。程序员应该养成新的习惯，在应用设计中采用各种加密技术保护个人隐私信息，包括个人账户、交易、浏览、日志信息等。

<strong>时间戳</strong>

传统关系型数据库在设计表时一般会有一个或多个时间戳（timestamp）字段，用来标记一行记录添加或修改时的时间。基本上，这些时间戳是给应用内部使用的。当数据被共享给其他应用时，这些时间戳并没有多大意义，因为时间戳可以伪造。在数据黑市上，一个数据掮客可以将一份银行VIP客户数据进行注水，掺入一半的假数据。一家保险公司为了搅乱市场上竞争对手的视线，故意污染数据，将高净值用户放入骗保用户黑名单，将骗保用户放入高净值用户名单，然后让污染后的数据故意泄露出去。如果每条数据都带有一个真实可信的时间戳（这条数据产生的真实时间点），这样的造假行为就比较难奏效，因为假数据的时间戳一般都是最近的。
以前我们很少关心数据的时间戳，很少去了解时间戳对数据的意义，一个原因也许是我们不知道如何用技术去实现这样的时间戳。如果技术实现完全可行，那么这个时间戳对我们来说就有了全新的意义。首先，我们有了真正可以信任的历史数据。第二，这些数据因为可信变得更有价值，可以在应用之外被其他应用或者分析工具使用。第三，我们可以基于这些可信的历史记录生成信用。最后，我们真正进入一个信用社会。
想象一下，如果我们想在未来某天证明自己的数据是在今天产生的，可以在今天对今天的所有数据进行某种形式的哈希（比如默克尔树），最终得到一个哈希值，然后在第二天的《参考消息》上登一个广告，把哈希值发布出去。明天的《参考消息》就成了我们的时间戳。如果明天我们想做同样的事，可以如法炮制，另外有一个关键点，那就是要记得把今天的哈希值也给哈希进去。这样每天的哈希值就包含了以前所有数据的哈希信息。
区块链在P2P网络上通过节点间的共识算法实现了一个分布式的时间戳服务。区块链是在时间上有序的、由记录块（区块）组成的一根链条。一个区块包含两个部分：区块头（Block Header）和记录部分。区块中的所有记录通过默克尔树（Merkle Tree）组织起来，默克尔树根（Root）的哈希值做为本区块里所有记录的数字指纹被放入区块头。区块头还包含以下字段：前一个区块头的哈希值（这是前一个区块的数字指纹，也可以看做是指向前一个区块的哈希指针），本区块的时间戳、高度（Hight，即从第一个区块开始数本区块是第几个块），以及一些其他信息。系统的共识算法保证了每过固定的一段时间（Bitcoin是大约10分钟），参与整个系统记账的节点会达成共识在区块链上添加下一个新的区块。
时间戳的这种设计，使得更改一条记录的困难程度按时间的指数倍增加，越老的记录越难更改。这是因为，如果改动某个区块里的一条记录，意味着该区块原来的默克尔树根失效了，需要改动区块头，该区块的数字指纹随之失效。又由于下一个区块的区块头包含这个哈希指针，这就意味着下一个区块也需要改动。如此直到最新的那个区块。可见要想改动一个区块，必须同时改动该区块后面的所有区块。因为将一个区块放入区块链中需要消耗非常多的资源（资源种类依共识算法的不同而不同，可以是计算力，流逝的时间，拥有的权益等），随着后面添加的区块越来越多，要想改动某个区块几乎是不可能的。
对一个普通应用来说，如何实现这样一个时间戳服务呢？我们需要自己创建一个区块链吗？其实没必要，Bitcoin就是一个很好的时间戳服务，我们可以把哈希值写到Bitcoin的区块链中。这是一种存在证明（Proof of Existence）。Factom也提供类似的服务，它收集所有的哈希，每隔10分钟生成一个哈希值，写到Bitcoin的区块链中。
哪些数据需要有时间戳？必须是不能变更的数据，特别适合存档文件。需要现在就考虑实施时间戳吗？这个跟你的数据战略相关。在大数据时代，拥有高质量的数据就是拥有了价值。时间戳可以一定程度上保证数据的可信度，至少这些数据是经过“时间考验”的。

<strong>总结</strong>

2009年1月Bitcoin发布，2015年7月Ethereum发布，到今年区块链开始大热。对于程序员和架构师来说，区块链带来了新的思维，新的程序设计范式，它所基于的技术也是一般程序员不太熟悉的。它号称要颠覆传统应用，要构造一个“价值互联网”。本文讨论了区块链三个有意思的方面：去中心和去中介、隐私保护、时间戳。程序员有必要了解这些有益的思路和技术，审视自己的应用和产品，看看是否可以借鉴，是否可以提升用户体验，增加数据价值，降低运营成本，或者是否有新的业务场景，也许还可以开创一条全新的业务模式。2016年10月，迪拜酋长国宣布在2020年前将所有交易转移到区块链的战略，预计每年可以由此节省2500万工时。区块链技术正在一步一步重新定义现实世界的交易和经济行为，不仅仅如此，它也在改革金融以外更广阔的方方面面。这篇文章将与大家一起由细到宏来思考区块链究竟如何用，如何落实每一步。

<strong>共享经济</strong>

【Airbnb与区块链】
Airbnb这类平台属于中心化的共享经济，类似的还有P2P租车的鼻祖ZipCar，他们都需要维护好平台上所有的出租记录以便让这些经济行为得到保障，这会消耗平台大量的劳动力。我认为Airbnb这类平台不应该把自己定位成中介，而应该真正去体现共享的意义，把房东和顾客最紧密的连接起来，平台本身不从中干预。但目前房东和顾客无法绕过Airbnb，因为他们需要Airbnb来为他们构建起信任桥梁，于是Airbnb成了信任中间商，甚至是监督者、大法官。我们可以想象一个未来：没有Airbnb但依然存在这种共享经济行为，谁来连接信息——区块链，谁来执行交易——智能合约，谁来建立信任——不可篡改以及全网公开。所以有这样一种趋势（其实国外也已经出现类似的区块链创业公司），智能合约取代Airbnb的商业模式，完成共享经济的去中心化，带来的好处就是消除了Airbnb带来的高比例中介费用。
收购ChangeCoin表示Aribnb已经重视区块链对自己带来的冲击和机会，相信这伙人会利用区块链深深改造Airbnb（国外互联网公司基本都有重视技术的传统，即使你做的是一个O2O租房打车，但依然将区块链技术和无人驾驶技术作为自己未来的赌注，国内需要越来越多的人来关注和应用区块链，正如人工智能在国内已经做的很不错了）。区块链记录着所有的历史交易，没人可以去篡改，同时这份大账本不保存在一个地方，而是每人都拥有一份，每发生一笔交易全网可见，天然公证不可篡改。Airbnb肯定看中的不是上面要干掉自己的用途，它看中的是这个大账本，可以存储自己引以自豪的交易明细、评分评论，区块链可以使这些数据财富永久保存、不被篡改、可追溯。还有一个目的，也是我比较看中的——共享信任数据。Airbnb会通过区块链将自己的数据（用户信任评分、评论）与其他平台共享（比如Uber、途家），来帮助更多的共享经济创业公司，最终为整个社会带来最全面的信任数据库，每一个人都会被影响。例如一家初出茅庐的P2P共享创业公司将不会为如何劝说平台上交易双方互相信任而发愁，我们都曾在这些大平台上留下自己的交易记录和信用，通过共享大平台的信任数据，创业小公司将会迅速发展。而这会产生滚雪球的效应，越来越多的信用数据形成联盟，每一个人的信用画像会越来越清晰，最终变成一张天网。区块链技术不仅可以去中心化的让这些平台数据共享，形成多维度的刻画，而且不可篡改，一个人的历史信用一旦发生将无法抹除。
高盛在长达88页的《区块链：将理论应用于实践》的报告中首次提到对区块链如何改造Airbnb的希冀：引入区块链打造的数字化信用系统来消除信任危机。高盛给出的做法是将公民身份证、护照、驾照、Airbnb、信用卡、网上购物等多维度反映身份和信用的指标融合成属于该公民的数字身份和信誉证书。
这将是一件对人类产生深远影响的布局和工程，它终将会像网络支付一样成为人们生活不可缺少的重要部分。
除此之外，高盛还给出如何利用区块链来完善Airbnb的评价系统：
“很多时候（比如饭店和零售业），在线用户评价经常是伪造的。有时候企业主可以建立多个消费者ID伪造正面评价，或者是寻求没有商业关系的朋友的帮助。还有些情况，竞争者会试图通过抹黑对手的评价来影响消费者的购买行为。区块链可以建立一个抗干扰的评价生态系统，其中包含真实评价者的电子签名，当验证评价者的确有购买行为（和支付）时，评价才会被接受。”
这同样具有实质性意义，就像我们使用滴滴、美团、途家的时候，最重要的不是关注价格而是去关注评论，有时候不能一味的怪罪商家的差评，因为背后的黑手我们并不清楚，确实需要这么一个近乎完全公证的系统和流程来让参与方放心。
Airbnb自己的区块链探索已经出发，期待继共享经济后再次带来震撼——信用经济。

【自行车P2P共享平台与智能合约】
智能合约是区块链作用共享经济的另一种方式，腾讯在2016中国科技金融FinTech创新大会上首次提出应用案例，而与之契合的是一家中国共享经济和区块链初创公司Gulu——短途出行工具的P2P分享平台（每个人均可以发布自己闲置的自行车电动车供附近的人租赁）。当我们因为出行和旅游观光需要租车，传统的做法是，找到一家专门的租车店并且抵押自己的身份证和押金租车，十分麻烦。那Gulu是如何利用区块链来解决这个痛点的呢？Gulu设计了一个由车主、用户和平台三方形成的区块链，用户在注册时会向账户托管一定金额的押金用来在线上代替身份证作为交易担保（我们使用携程时有时候会让我们预付与房价同等数值的担保金），当然这笔钱在你不需要租车的时候可以随时实时退还。当你通过平台预订了一个车主的车子后，押金将会与此次交易绑定，平台会通过智能合约来约定这笔押金如何来规范交易行为，比如我超时还车，智能合约将自动从押金中扣除相应数额。
除了腾讯描述的这个案例外，Gulu还有一个场景使用智能合约。如果车主的自行车是传统自行车，需要用户与车主线下见面交付钥匙和车辆，为了提高效率，Gulu会引入智能单车，或者帮助车主将传统自行车改造为具有GPS定位和扫码解锁功能的智能单车，用户线上预订后就能获得该车的数字钥匙，由智能合约来约束，根据导航找到车辆，利用手机获得的数字钥匙解锁骑车，超时同样会由智能合约来扣除相应金额。这是共享经济、智能硬件和智能合约三者的一个结合，希望这一尝试会给更多区块链应用领域（尤其是租车行业）带来探索。

【智能合约与Slock.it】
智能合约的潜力亟待释放，但截止目前我们的生活还未受到智能合约的控制。不过就像最近几年正逐步实质性影响人类生活的人工智能一样，智能合约也在慢慢解放人力和决策。我没有经历过互联网诞生的那一刻，不知道经历过的人是否对区块链有同样的触动，而恰恰智能合约是90年代由尼克萨博提出的理念，几乎与互联网同龄，由于缺少可信的执行环境，智能合约并没有被应用到实际产业中，直至比特币出现，人们发现区块链天生可以为智能合约提供可信的执行环境。这些都在为智能合约完全渗入人类生活的方方面面慢慢铺实道路，如同阿里巴巴当初创造支付宝只是为了解决网上交易付款问题，但如今的进化和普及使得网上支付完全影响每一个人的财产和支付。相信支付宝刚刚诞生的那一刻，很多人都无法感知它日后带来的巨大影响，银行业当时也没有采取措施，致使如今不得不背水一战。
有人这样描述了一个智能合约影响生活的例子，细思极恐。未来我们几乎所有的资产都会成为嵌入智能合约的智能财产，比如你的汽车所有权和使用权将掌握在该汽车的数字钥匙上，一旦你没能偿还贷款，银行瞬间就可以收回你的汽车，你无法赖着不抵押。或许未来的生活会被智能合约的条条框框锁定住，人与人之间的信用开始进化。
以太坊较早看到了区块链和智能合约的契合，而Slock.it就是建立在以太坊上的智能合约初创公司。或许我们可以从它的模样里窥探到未来智能合约到底会如何影响我们的生活。它以一种完全去中心化的方式运作，建立在以太坊区块链的基础上，它会构建出区块锁（智能合约）将租赁人和产权人直接连接起来，这个区块锁可以控制资产，区块锁的所有者可以设置该资产的预付款和租赁价格，用户通过以太坊区块链发送一笔交易支付预付款，区块锁便会将资产的使用权直接转移给用户。当用户通过以太坊发出归还使用权的交易时，区块锁自动执行，将租赁费用转账给出租人，而余款退还给租赁人。
我们可以从Slock.it隐隐约约看到这样一个未来：你只需要为你的房子、自行车、汽车、洗衣机、割草机安装区块锁Slock，每次租赁交易都将由智能合约自动执行。

<strong>供应链</strong>

【供应链+物联网+区块链=未来】
供应链也是目前区块链能影响到的一个比较清晰的场景， 而IBM在这方面走在了前面，让我们来解释一下它提出的这个公式：供应链+物联网+区块链=未来。
IBM给出了一个集装箱案例：
“某人要将存放在集装箱中的货物运送至其他国，船务公司肯定是供应链网络中的一环，他们必须确保集装箱中的货物顺利通过海关检查。而海关可以直接在链上进行验证，确认货物已经到港。由于物联网（IoT）的应用，集装箱在送至边境检查之前就进行了地点和信息防篡改的验证及登记，这样就节省了物流公司的时间。另外，通过这种方式，供应链中所有的参与者都能承认这一过程的真实性，因为区块链上的记录是不可更改的。”
区块链可以让供应链上的各个参与者能够绝对信任信息的真实性，而物联网让信息采集和验证无处不在。区块链在供应链的应用中充分发挥了自己的两大特点：各个节点分布式去中心化存储（横向）、持续增长而不可篡改的链条在共识机制下记录数据并永久存储（纵向）。供应链本身就涉及整个上下游参与者多个中心，是一个由核心生产企业、供应商、供应商的供应商、客户和客户的客户组成的多主体链条，没有一个主体愿意完全分享自己的信息。还有一个交易成本问题，供应链合作伙伴之间的交易存在不信任，到底是先交钱还是先验货，需要一个信任机制，或者是共识机制和智能合约。典型的核心企业的供应链管理流程包括计划、采购、制造、交付、回收等五个部分，上游供应商和下游客户也是这五个部分，而每一部分又需要供应商、客户、第三方服务供应商多方参与，因此供应链就是由企业内部和企业之间众多主体组成的网络，当这个网络变成区块链结构时，像产品溯源问题、物权交接、实时跟踪、售后记录问题都将得到解决。

【食品区块供应链】
在Everledger用区块链记录钻石的整个生命流程来达到防伪目的后，沃尔玛联合IBM、清华也开始为食品行业打造一个区块供应链，让人们吃上放心的猪肉。该项目使用了HyperLedger技术来准确记录猪肉供应中的批次号、过期日期、储存温度和运输细节等与食品安全息息相关的数据。网络由沃尔玛、IBM、供应商三个节点构成，当猪肉在沃尔玛超市出售给消费者时，消费者可以通过扫描来获取这块猪肉整个生产流程信息，因为信息来自多分共同维护的区块链网络，不可篡改，真实可信。
这将为供应链行业带来前所未有的信息公开和真实。


<strong>物联网</strong>

【自治的传感器节点】
多年前人们开始向往由物联网打造的智慧城市和智慧地球，但似乎一直无法实质性影响我们的生活，倒是移动互联网深深影响了每一个生活细分。截止目前的物联网依然是由一个中心化的数据中心收集所有已连接设备的信息，这不仅导致性能瓶颈也会造成信息封闭，无法形成互联网。IBM似乎已经找到了一个优雅的解决方案：每个设备和传感器节点都应当自我管理，无需中心化控制，设备的运行环境应该是去中心化的，它们彼此相连，形成分布式云网络。
导致如今物联网无法做到互联网那种联网规模的一个原因在于，联网设备数目无法做到很多，否则现在的中心化管理机制无法来管控和验证所有节点的身份，更无法确保安全。互联网是没有中心的，人与人的连接自由而庞大，同样的道理需要体现在物联网上，但物联网是由设备和智能硬件组成，不像人拥有自主意识，所以目前我们通过中心来管控，而区块链和智能合约让这些设备和节点能够脱离中心自主的在网络里产生行为。
【Filament与“设备民主”】
Filament是一个建立在区块链上的去中心化物联网软件堆栈，能够使公共分类总账上的设备持有独特身份，通过创建一个智能设备目录，Filament的物联网设备可以进行安全沟通、执行智能合约以及发送小额交易。
它的愿景之一是通过这些软件堆栈和自己的硬件帮助企业更好地管理农业灌溉，不需要再使用效率低下的中心化云方案或文件式的老方案。Filament希望所有连接的设备之间能够进行去中心化的沟通。
与Filament有着共同洞察的IBM在一份报告中表露了自己的雄心——低成本、私人订制的民主设备将会出现。或许IBM会重新改造多年前构造智慧星球的物联网结构，它已经开始明白当前互联网式的物联网，其规模是不足以联动数以亿计的智能设备的，应该转变成区块链式的物联网。
或许在区块链的改造下这一次物联网将会真正影响这个星球，万物联网将会比移动互联更激动人心。

<strong>银行、公益和法律</strong>

【跨境转账与C2B】
渣打银行利用瑞波的区块链技术成功完成十秒实时跨境支付，而在以前则需要长达数个工作日，期间各方收取的费用也不少。所以银行是目前区块链改革浪潮里最积极的行业，再不主动走在前面将会是灾难性的。
除此之外，区块链更重要的意义是让C2B大规模定制化交易场景成为可能，消费者与生产厂商直接点对点建立交易关系，绕过繁琐的中间N多环节。

【爱心捐款的未来】
我个人比较青睐的一个已经落实的区块链案例是蚂蚁金服打造的区块链爱心捐赠平台，我感觉这将会是一个让社会越来越温暖和互相关怀的壮举，如同前面提到的数字身份和信誉系统一样将会对人性产生深远影响，我们会变得越来越关怀彼此，关心需要帮助的人，几块钱几十块对我们来说只是一顿饭钱，但我们可以用它帮助那些有困难的人。为什么到现在我们没有在社会形成这个互帮互助的民风，我相信很大一部分原因就在于捐款黑暗和乱，我们不信任所谓的慈善机构，我们没有底自己的这些钱到底如何来帮助灾区孩子。支付宝做了一个区块链公益项目爱心捐赠平台，利用区块链技术，让每一笔款项的生命周期都记录在区块链上，用户可以持续追溯，我会知道捐出的五十块用来帮助灾区的一个孩子购买了学习用具，每个人都能查看“爱心传递记录”，能看见项目捐赠情况，善款如何拨付发放，而且一笔款项的去向将不可篡改。

【法大大与电子存证】
法大大是国内区块链改造法律行业的代表性创业公司，最近也完成了6000万元B轮融资，是一家做电子合同签署及托管的SaaS平台。在今年的云栖大会上阿里云邮箱与法大大合作了电子邮件存证。在商务沟通上，电子邮件作为主流方式承载着重要的角色，但目前邮件很容易被篡改和抹除，一旦发生纠纷将无从取证，阿里云邮箱将会与法大大以及其他机构组成区块链网络，使得每一封邮件都会在网络里被公证和永久保存，为日后的纠纷保留好真实证据。

<strong>IBM的Fabric</strong>

目前诞生的领军型区块链平台有以太坊和瑞波，同时IBM HyperLedger Fabric也成为企业级区块链平台的代表性架构。“蓝色巨人”几乎没有放过任何一项划时代的颠覆性技术，它在区块链的布局和动作也已经走在了前面。
IBM已经开始在公司内部应用基于Fabric打造的目前最大规模的区块链商业系统，用以加快IBM内部的交易追溯和验证，预计将使IBM全球金融部门在交易纷争中节省约1亿美元的资金，实实在在的价值将会出现。
IBM区块链技术副总裁Jerry Cuomo表示：“这一应用涉及4000名供应商、商家、金融消费者，每年涉及300万笔交易，共计440亿美元的成交金融。每年都有大约2.5万起类似电脑零部件订单错误或快递错误等纠纷。目前，解决这样一个问题平均需要44天，要求员工通过6到7个不同的应用来追溯历史步骤，有时候还需要联系银行和其他涉及到的参与方。而将交易详情记录在区块链账本上将会使追踪交易详情更加快速，而且比目前IBM的处理流程更加准确。这个新的项目系统与IBM现有的金融应用并行运作，在交易过程中的关键节点使用顾客代码收集数据，例如下单时间、送货时间、付款时间等。
过去几场测试中，IBM成功将这个过程缩短至10天，有了这项应用，我们将可以避免损失1亿美金。”
在这过程中发挥重要底层作用的IBM Fabric架构也是非常优秀的设计，我了解的国内好多创业公司推出的架构基本都是从Fabric演化过来，而Fabric极力推荐的拜占庭共识机制在工业生产中具有特别实用的价值。

<strong>尾声</strong>

如同移动互联网早期一样，我们需要几年的耐心，等所有的基础设施和应用场景都越来越牢固和清晰时，终将会迎来像如今的移动互联网一样的爆发。而国内甚至全球擅长区块链技术的人才奇缺，只有数千人，远远小于人工智能领域，好在国内高校已经开始重视区块链研究方向。所以变革终将到来，但依然需要耐心等候。长久以来，开发者总是有不可思议的致命自负：坚信黑科技中神话力量的存在。凭借它可以迅速打造出一款引爆市场的“雷锤”，催枯拉朽地颠覆一切，区块链行业也不例外。然而诞生八年，具有全球影响力的区块链产品，目前仍然只有创始人中本聪先生的那一款。不论中国还是美国，初步具备市场和用户规模的也聊聊无几。更多的在潮起潮落中消逝，在滚滚泡沫中覆灭。我们不能否认，技术创业者的产品打造是一个复杂的过程，但更多时候，技术本身的特质也一定程度上决定了产品未来的成败。区块链的确有很大的可能，但绝非万能。正如老生常谈“没有银弹” 。如果希望商业上获得成功，我们不妨从以下四个角度来对区块链技术做个简单分析，看它适宜于什么场景。

<strong>“不要拿大炮打蚊子”：区块链技术更适宜于资产网络：（Assets Over IP）——定律1</strong>

区块链一开始是作为比特币的底层网络协议出现的，比特币则被设计为一种点对点的数字现金，并希望广泛应用于世。但这种世界互联网货币的梦想并未完全实现，目前更多的国家是将比特币等作为数字资产、数字商品来看待。尽管如此，这种网络设计对后世种种区块链系统的影响极为深远，基本现有所有的区块链网络都参考了比特币代码，例如以太坊、Corda、Hyperledeger、Factom、域名币。这些网络大多有如下特征：
 网络上流通的，不再是正确或错误、廉价的、长短不一、格式杂乱的“信息”，而是需要一定程度加以保护的稀缺“资产”（这里资产为广义，不论是股权、债券、代币、彩票、还是某种有价值的权益证明）。
 整个网络运作的逻辑围绕加密、签名、验证、交易、确认、读、写、执行合约等展开。按照一定规则，有确定时延地运转：包括生成块、链或者其他名称的“账本”或数据记录、全局状态记录，并不断通过默克尔树剪枝操作摒弃冗余、错误、失效的数据。
我们不妨从两个方面看待这个网络：一方面，这是一个总体“廉价”的网络，网络基础设施的搭建被开源社区和诸多参与者分担。另一方面，这也是一个“运行昂贵”的网络，不论是达成一致性的时间成本，还是需要为验证者提供代币或“燃料币GAS”的花费。最初的设计基因决定了这个强规则网络的“使用成本”较高，而反过来高成本则又进一步加强这一趋势：必须稀缺的，“资产”属性的操作在这个网络上运作，才能够达到预期的收益率，以维持产品使用者在网络的消耗。“不要拿大炮打蚊子”，也不要拿区块链做廉价的口水化聊天工具或者一般文件传输系统，最好与有价的资产相关，这一点是产品开发者首要考虑的。

<strong>适用于具有多个弱信任、对等的写入权限节点的数据库——定律2 </strong>
区块链网络不论是联盟链中准入的实名参与机制者，还是公有链中随机的匿名参与者都有一个共同处：在使用区块链之前，一般是不存在信任关系或弱信任关系的。节点间一般进行资产交互的方式是信任第三方，然后通过第三方实体进行“资产”属性数据或凭证的“传递”和“交换”操作。这个过程中，交互的复杂性会增加，第三方机构提供担保，协助达成共识，而收取服务费用。区块链产生后充当的角色有：公共操作记录的数据库、信任的锚定者等。这个数据库需要一群互不信任或缺乏信任的节点共同协作，按照既定规则进行“写”操作。而“读”和“执行”的权限则开放给相应权限的参与者。一个适合传统的C/S模型硬性改造成区块链也是毫无意义的。

<strong>适用于去中心化的解决方案——定律3</strong>
这一点无需多言，如果一款区块链产品需要满足的需求，现有的中心化方案可以成熟、完善地解决，则这款产品完全没有必要存在。以下为案例种种：

【真伪场景：“跨境支付”vs“支付”（参见定律 3 ）】
首先我们考虑跨境的小额汇款（remittance）行业，传统的方式进行汇兑，从马来西亚一家银行到印度的班加罗尔一家小商户，会经过多个中转行，整个过程复杂且不透明，从付款到收款需要2～4天左右，且汇费较高。究其本质：是因为各个国家小的金融机构之间存在不信任，存在区隔。现在，引入公开透明、可查证、溯源的区块链作为协议链接起来，让整个过程透明性更高，降低中转、合规、审计成本。它可以增强信任，解决复杂多边市场中缺乏“中心协调者”，存在严重对手风险的交易困境。以往的跨境汇款成本是在每笔26美元左右，相当于一百多人民币，如果做外劳、留学、旅游等千元、万元级别的小额汇款，成本就非常高，甚至不现实。但区块链上的跨境汇款产品，例如OKLink，对于小额汇款，每笔费率只有0.3%。这样能给各个国家中小金融机构和小笔量汇款提供更多的选择和可能性。

【真伪场景：“通用积分”VS “积分”（参见定律2）】
积分是一种企业增加用户忠诚度以及活跃度的营销手段，然而消费者面临的现状是，手上的积分种类太多，管理困难，而且价值不高，想用用不了，积分逐渐演变成“鸡肋”。但如果多个企业的商户利益形成联盟，大的集团内部不同的子公司之间，制定一定的游戏规则，使用区块链构建一个企业间通用积分平台，进行积分的授予、承兑、结算，则会有探寻的空间。比如利用航空积分兑换通用积分，进行租车消费，那在这个系统里就会出现多个可以“写”数据的操作者，而非单方的积分授予者，这样才有技术契合的可能。

【真伪场景：“存证”VS“存储”（参见定律1）】
利用区块链上的哈希时间戳，几乎可以鉴证任何文件和数字资产，证明某个权益文件和数字资产在某个特定时间已经存在，这对法律证据、合同、遗嘱证明带来了革命性的改变，我们称之为存证。
音乐、电影、一般文件文档等资产无关数据可以构建专门的区块链系统进行分布式存储，技术上是可以实现的。然而根据定律1，我们可以发现此种产品的商业逻辑漏洞明显。此前有一系列去中心化的云存储项目，对标Dropbox以及网络云盘服务，曾在风口上获得了百万美元级别的天使轮融资，不出意外的是，近期大多数此类项目都死掉了。

<strong>结束语</strong>

考虑“区块链技术如何应用”对开发者而言，无伤大雅，毕竟还在发展的早期，多做技术尝试增加开发能力怎么说都不为过。但对产品经理而言，则是常见的错误思路和不可挽回的噩梦。毕竟区块链不是工具性的技术，而是一个新系统、新网络。也许，我们要考虑的问题并不是：用区块链技术为我们产业做什么，用这样的锤子怎样钉我们的钉子？而是：未来必然会来到，在区块链网络出现后，我们应该怎么融入，以怎样的产品产生怎样新的交互？这样的思路下，重新思索，也许可以使你的区块链产品不仅度过盛夏，也能活过寒冬。<strong>以太坊是什么？</strong>
以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。就像比特币一样，以太坊不受任何人控制，也不归任何人所有——它是一个开源项目，由全球区块链爱好者共同创建。和比特币协议有所不同的是，以太坊的设计十分灵活，极具适应性。

【比特币 vs 以太坊】
如果对比特币和以太坊，一个形象的比喻是计算器和智能手机，计算器只有一些内置的加减乘除功能，智能手机可以安装实现各种功能的App。因此，比特币会在金融支付等特定领域发挥价值，而以太坊可以为各行各业提供解决方案。

<strong>以太坊发展历史回顾</strong>

2013年末以太坊创始人Vitalik Buterin第一次描述了这个项目，作为他研究比特币的成果。不久后，Vitalik发表了以太坊白皮书，书中详细描述了以太坊协议的技术设计和基本原理，以及智能合约的结构。2014年1月，Vitalik在美国佛罗里达州迈阿密举行的北美比特币会议上正式宣布了以太坊。
与此同时，Vitalik开始和Gavin Wood博士合作共同实现以太坊。2014年4月，Gavin发表了以太坊黄皮书，作为以太坊虚拟机的技术说明。按照黄皮书中的具体说明，以太坊客户端已经有8种编程语言实现。
从2014年6月开始，以太坊借助42天公开的以太币预售活动对第一批以太币进行了分配，共筹集31591个比特币，当时价值1843万美元，交换出大约6000万以太币。众筹所得主要用于回报开发者们数月以来的努力，以及资助以太坊的持续开发。这笔资金为以太坊后续的发展提供了充足的的资金保证。
经过两年的快速发展，在以太坊平台上创立新的应用十分简便，随着Homestead的发布，任何人都可以安全地使用该平台上的应用。

<strong>以太坊核心概念之虚拟机（EVM）</strong>

以太坊是可编程的区块链。它并不是给用户一系列预先设定好的操作（例如比特币交易），而是允许用户按照自己的意愿创建复杂的操作。这样一来，它就可以作为多种类型去中心化区块链应用的平台，包括加密货币在内，但并不仅限于此。
以太坊狭义上是指一系列定义去中心化应用平台的协议，它的核心是以太坊虚拟机Ethereum Virtual Machine（EVM），可以执行任意复杂算法的编码。在计算机科学术语中，以太坊是“图灵完备的”。开发者能够使用现有的以JavaScript和Python等语言为模型的其他友好的编程语言，创建出在EVM上运行的应用。熟悉JVM的同学很好理解，EVM就是一个程序运行的容器。
和其他区块链一样，以太坊也有一个点对点网络协议。以太坊区块链数据库由众多连接到网络的节点来维护和更新。每个网络节点都运行着EVM并执行相同的指令。因此，人们有时形象地称以太坊为“世界电脑”。

<strong>以太坊如何工作？</strong>

以太坊合并了对比特币用户来说熟悉的特征和技术，同时自己也进行了修正和创新。比特币区块链纯粹是一个关于交易的列表，而以太坊的基础单元是账户。以太坊区块链跟踪每个账户的状态，所有以太坊区块链上的状态转换都是账户之间价值和信息的转移。账户分为两类：
1. 外部账户（EOA），由私钥控制；
2. 合约账户，由它们的合约编码控制，只能由外部账户“激活”
对于大部分用户来说，两者基本的区别在于外部账户是由人类用户掌控——因为他们能够控制私钥，进而控制外部账户。而合约账户则是由内部编码管控。如果他们是被人类用户“控制”的，那也是因为程序设定它们被具有特定地址的外部账户控制，进而被持有私钥控制外部账户的人控制着。“智能合约”这个流行的术语指的是在合约账户中编码——交易被发送给该账户时所运行的程序。用户可以通过在区块链中部署编码来创建新的合约。
只有当外部账户发出指令时，合约账户才会执行相应的操作。所以合约账户不可能自发地执行诸如任意数码生成或应用程序界面调用等操作——只有受外部账户提示时，它才会做这些事。这是因为以太坊要求节点能够与运算结果保持一致，这就要求保证严格确定执行。
和比特币一样，以太坊用户必须向网络支付少量交易费用。这可以使以太坊区块链免受无关紧要或恶意的运算任务干扰，比如分布式拒绝服务（DDoS）攻击或无限循环 。交易的发送者必须在激活的“程序”每一步付款，包括运算和记忆储存。费用通过以太坊自有的有价代币，以太币的形式支付。 
交易费用由节点收集，节点使网络生效。这些“矿工”就是以太坊网络中收集、传播、确认和执行交易的节点。矿工们将交易分组（包括许多以太坊区块链中账户“状态”的更新），分成的组被称为“区块”，矿工们会互相竞争，以使他们的区块可以添加到下一个区块链上。矿工们每挖到一个成功的区块就会得到以太币奖励。这就为人们带来了经济激励，促使人们为以太坊网络贡献硬件和电力。 
和比特币网络一样，矿工们有解决复杂数学问题的任务以便成功地“挖”到区块，这被称为“工作量证明（POW）”。一个运算问题如果在算法上解决比验证解决方法需要更多数量级的资源，那么它就是工作证明的极佳选择。为防止比特币网络中已经发生的，专门硬件（例如特定用途集成电路ASIC）造成的中心化现象，以太坊选择了难以存储的运算问题。如果问题需要存储器和CPU，事实上理想的硬件是普通的电脑。这就使以太坊的工作量证明具有抗特定用途集成电路性，和比特币这种由专门硬件控制挖矿的区块链相比，能够带来更加去中心化的安全分布。 

<strong>以太坊基础使用指南</strong>

以太坊上线之前计划的初始开发路线图主要有以下几个里程碑：

1. 预发布：Olympic testnet —— 2015年5月
2. 发布第一版：Frontier —— 2015年7月30日
3. 发布第二版： Homestead —— 2016年3月14日（π日）
4. 发布第三版： Metropolis —— 预计2017年上半年
5. 发布第四版：Serenity——未知
通过本节可以获取用户参与以太坊项目中的基本方法。首先，要想成为网络中的节点，需要运行一个以太坊客户端。

【以太坊客户端的选择与安装】
为什么有多个以太坊客户端?
以太坊客户端与Java虚拟机和.NET运行环境类似，能够让你在电脑上运行“以太坊程序”。以太坊客户端按照书面说明（黄皮书）执行，可以彼此协作，因此，你可以使用Go、C++、Java等熟悉的语言来参与以太坊网络。
项目早期，在众多不同的操作系统中就有多个可以彼此协作的客户端实现，客户端的多样性对于整个生态系统来说是巨大的成功。它使我们能够证明协议是明确清晰的，为后续创新打开了空间，也让我们都保持诚实。但是对终端用户来说，没有通用的“以太坊安装程序”可供他们使用，可能引起他们的困惑。
进入到Homestead阶段以后，Go客户端占据了主导地位，但情况并不一直是这样，将来也说不定。除了EthereumH，其他客户端都有Homestead兼容的版本。目前有8种客户端：C++、Go、Python、Java、JavaScript、Haskell、Rust、Ruby。

<strong>公有链、联盟链、私有链介绍</strong>

当今大多数以太坊项目都选择了以太坊公有链，公有链可以接触到更多用户、网络节点、货币和市场。但有些领域则更偏好私有链或联盟链（在一群值得信任的参与者中）。例如，银行、保险领域的很多公司都希望以太坊作为他们私有链的平台。
三种区块链在许可方面的区别：
1. 公有链：所有人都可以阅读和发送交易，合法信息都会被包括在内。任何人都能参与到共识形成过程——决定在链条上添加什么区块以及现状是怎样的。作为中心化或准中心化信任的替代品，公有链受加密经济的保护，加密经济是经济激励和加密验证的结合，用类似工作量证明或权益证明的机制，遵循的总原则是人们影响共识形成的程度与他们能够影响的经济资源数量成正比。这类区块链通常被认为是“完全去中心化”。
2. 联盟链：共识形成过程由预先选择的一系列的节点所掌控，例如，设想一个有15个金融机构的团体，每个机构都操作一个节点，为了使区块生效，其中的10个必须签署那个区块。阅读区块链的权利可能是公开的，或仅限于参与者，也有混合的路径，比如区块的根哈希和应用程序编程接口一起公开，使公共成员可以进行一定量的查询，重获一部分区块链状态的加密证明。这类区块链被认为是“部分去中心化”。
3. 私有链：写入权限对一个组织保持中心化。读权限可能是公开的或者限制在任意程度。应用很可能包含对单个公司内部的数据库管理，审查等，因此公共的可读性在很多情况下根本不必要，但在另一些情况下人们又想要公共可读性。
在未来的区块链行业解决方案领域，联盟链可能会扮演很重要的角色。

<strong>以太坊账户管理</strong>

账户在以太坊中发挥着中心作用。前面我们讲了共有两种账户类型：外部和合约账户。这里重点讲一下外部账户，以下会简称为账户。如果我们把以太坊限制为只有外部账户，只允许外部账户之间进行交易，我们就会进入到“代币”系统，这样就类似于一个比特币网络。

【钥匙文件】
每个账户都由一对钥匙定义，一个私钥和一个公钥。 账户以地址为索引，地址由公钥衍生而来，取公钥的最后20个字节。每对私钥和地址都编码在一个钥匙文件里。钥匙文件是JSON文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分是账户私钥，通常用你创建帐户时设置的密码进行加密。钥匙文件可以在以太坊节点数据目录的keystore子目录下找到，一定要确保经常给钥匙文件备份。
创建钥匙和创建帐户是一样的，在此过程中：
1. 不必告诉任何人你的操作
2. 不必和区块链同步
3. 不必运行客户端
4. 不必连接到网络
当然新账户不包含任何以太币，但它将会是你的，大可放心，没有你的钥匙和密码，没有人能进入。转移备份整个目录或任何以太坊节点之间的个人钥匙文件都是安全的。

【创建账号】
使用geth account new
一旦安装了geth客户端，创建账号就只在终端执行 geth account new指令就可以了。
注意不必运行geth客户端或者和区块链同步来使用geth account指令。
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3339">代码1</a>
警告：记住密码并“备份钥匙文件<backup-and-restore-accounts>”。你必须同时有钥匙文件和密码才能从账号发送交易，包括发送以太币。确保钥匙文件有个备份并牢记密码，尽可能安全地存储它们。如果钥匙文件丢失或忘记密码，就会丢失所有的以太币。没有密码不可能进入账号，也没有忘记密码选项，所以一定不要忘记密码。

要列出目前在你的keystore文件夹中的钥匙文件的所有账号，使用geth account指令的list子指令：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3340">代码2</a>
使用geth控制台
也可以通过控制台创建新账号，我们必须先在控制台模式开启geth
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3344">代码3</a>
控制台使你能够通过发出指令与本地节点互相作用。比如，试一下这个列出账号的指令：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3346">代码4</a>
这就表明你没有账号。你可以从控制台创建一个账号：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3349">代码5</a>
我们刚刚创建了第一个账号。如果再次试着列出账号，就可以看到新创建的账号了。
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3351">代码6</a>

<strong>案例演示：通过命令行做转账操作</strong>

安装完以太坊客户端，就可以使用命令了，以Go语言客户端为例。 
查看帮助命令：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3354">代码7</a>
列出账户：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3356">代码8</a>
指定目录启动一个节点： 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3358">代码9</a>
进入控制台：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3359">代码10</a>
列出账户：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3360">代码11</a>
指定密码为123456，创建一个账户 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3361">代码12</a>
创建第二个账户 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3362">代码13</a>
取出第一个账户，赋值给user1 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3363">代码14</a>
取出第二个账户，赋值给user2
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3364">代码15</a>
查看user1初始余额 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3365">代码16</a>
查看user2初始余额
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3366">代码17</a>
查看当前区块号
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3367">代码18</a>
启动挖矿 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3368">代码19</a>
查看当前区块号
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3369">代码20</a>
查看user1当前余额
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3370">代码21</a>
查看user2当前余额
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3371">代码22</a>
停止挖矿 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3372">代码23</a>
查看当前区块号
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3373">代码24</a>
user1转账给user2（会报错，请看下一步）
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3374">代码25</a>
转账涉及到资金支出，需要提供密码解锁转出账户 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3375">代码26</a>
重新执行转账操作： 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3376">代码27</a>
转账成功以后，查看user1和user2余额 
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3377">代码28</a>
好了，一个完整的命令行转账功能就完成了。

<strong>15分钟编写一个区块链Web应用：truffle开发入门</strong>

以太坊是区块链开发领域最好的编程平台，而truffle是以太坊最受欢迎的一个开发框架。实战是最重要的事情，这一节不讲原理，只搭建环境，并运行一个区块链程序。 

【安装truffle】
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3378">代码29</a>

【依赖环境】
访问https://nodejs.org 官方网站下载安装NodeJS
推荐Mac OS 系统，不建议使用Windows，会碰到各种各样的问题，导致放弃。
需要安装Ethereum客户端来支持JSON RPC API调用开发环境，推荐使用EthereumJS TestRPC: https://github.com/ethereumjs/testrpc
安装命令：
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3379">代码30</a>

【新建第一个项目】
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3380">代码31</a>
默认会生成一个MetaCoin的demo，可以从这个demo中学习truffle的架构
项目一级目录结构如下：
/Users/bob/workspace/zhaoxi/
▶ app/
▶ contracts/
▶ migrations/
▶ test/
     truffle.js
项目所有文件目录如下：
/Users/bob/workspace/zhaoxi/
    ▼ app/
       ▼ images/
       ▼ javascripts/
            app.js
       ▼ stylesheets/
           app.css
         index.html
    ▼ contracts/
         ConvertLib.sol
         MetaCoin.sol
         Migrations.sol
    ▼ migrations/
         1_initial_migration.js
         2_deploy_contracts.js
    ▼ test/
         metacoin.js
         truffle.js

【编译项目】
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3381">代码32</a>

【部署项目】
部署之前先启动TestRPC
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3382">代码33</a>

【启动服务】
<a target="_blank" href="http://ipad-cms.csdn.net/cms/article/code/3383">代码34</a>
启动服务后，可以在浏览器访问项目：
http://localhost:8080/ ，网页界面如图1所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/586609ab86b46.png" alt="图1  网页服务界面" title="图1  网页服务界面" />
好了，第一个Web区块链程序跑起来了，后面可以不断地实践深入学习了。

【参考资料】
以太坊官方网站：https://ethereum.org/
汪晓明的博客：http://wangxiaoming.com/
以太坊开发视频：http://ethcast.com/
以太坊爱好者：http://ethfans.org/著名的金融领域分布式账本R3项目由于有众多金融机构的参与和支持，并且获得了数千万美元的融资，自宣布之日起就受到整个区块链生态环境的瞩目。从公布的一些新闻稿、白皮书中，人们已经了解到：R3的最大特点之一，就是一个没有区块链的“类区块链”系统，但是具体实现方案是什么，与区块链相关的系统对比又有什么特色，还是一个未知数。
随着R3的基础设施Corda项目在2016年11月30日宣布开源，笔者在第一时间对其技术白皮书、在线文档和源代码做了初步的阅读和分析。我们看到Corda的交易验证、共识机制等特性，采用了基于Notary（公证员）的模式。同时，为了服务于现实世界中的企业，Corda还具有很多与外部世界通讯的能力，例如：汇率、股票价格等信息的接收，可以通过一个叫做Oracle（先知）的角色来实现。总之，与此类似的设计还有不少，这一系列选择都是R3根据自身定位有意为之。R3 Corda是一个基于半信任环境的、服务于现实世界金融活动的分布式账本，同时满足信息适度可见和高性能两个核心特性。
Corda区别于其他“类区块链”系统的另一个重要特点，就是系统本身基于一个小众语言Kotlin来开发，运行在JVM之上。从实现层面来看，Corda有着鲜明的Java生态环境特点，例如：其节点使用的通讯、存储技术都是Java领域普遍采用的开源框架组合模型，相信这一点使得Corda非常适合企业使用，同时其自身开发成本也很低。此外，Corda中的合约（contract）以及Dapp应用，原则上是可以基于JVM上的任何语言来开发的，在应用开发者层面，一定程度上减小了kotlin小众化问题的影响。
除此之外，Corda作为较新的类区块链平台，还有很多令人关注的特性，本文将对其与区块链概念相关的各方面特性做一个概览，以便读者较为快速地了解这一著名的金融领域分布式账本。

<strong>基本概念与模型</strong>

【去中心化数据库（Decentralized Database）】
在技术层面上，Corda的定位是一个“去中心化数据库”，这一点对于理解Corda的设计和实现理念是非常重要的。
首先，在概念层面，去中心化数据库与分布式数据库有着重要的区别：分布式数据库仍然是一个中心化的系统，其服务目标是接收客户端的消息来存储数据，重点关注的是解决系统内部各个节点之间数据同步的问题。去中心化数据库，则是相互独立的参与方各自的私有数据库，在一定前提条件下同步某一方面的数据，如果参与方之间不完全的互相信任，则无法使用分布式系统中标准的数据同步算法。因此，两类系统的关注点、设计和实现模式大相径庭。
其次，在实现层面，去中心化数据库并不限于一种特定的技术：区块链这一随着比特币诞生的基础设施，可以认为是去中心化数据库的一种实现方式，也是现阶段获得最多认可的一种方式，但不是唯一的方式。从这个角度讲，Corda通过一系列的设计，给我们带来了去中心化数据库的另一种实现方案，这就是Corda系统的核心价值，一旦为人们所接受，必然会在“类区块链”生态系统中占有一席之地。
因此，Corda系统中最基本的概念、数据结构、算法和实现方式，在技术层面都是围绕“去中心化数据库”这一概念来完成的。

【状态（State）与UTXO】
状态是Corda网络中最基本的概念，我们可以理解状态就是“系统中的事实”，例如：“Alice拥有5000美元”，这就是一个状态。Corda系统的状态设计是基于交易的，也就是说只有一个有效交易的输出才是系统认可的有效状态，这实际上就是人们已经比较了解的UTXO模型。系统中还可以有另一个状态，就是“Alice拥有3000美元”，这是Alice参与的另一个交易产生的输出。假定系统中不再有任何Alice拥有某种资产的事实存在的话，那么从现实世界的角度看，可以认为Alice拥有8000美元。但是，Corda系统中并不存在“Alice拥有8000美元”这一事实，只有前述两个事实。熟悉“类区块链”系统的人都知道，在一个UTXO模型的系统中，Alice只有跟自己做一次交易，以前述两个状态作为输入，才能产生一个新的“Alice拥有8000”美元的状态。与此同时，前两个状态在系统中也就失效了。
与基于交易的状态模型对应的，是所谓基于账户的状态设计。也就是说，每一个交易会形成对账户状态的改变，就像银行存款账户的“余额”会随着该账户的每一次交易而变化。以太坊等区块链系统，采用的就是基于账户的模型（可能有人知道，Serenity声明也支持建立一个UTXO模型的代币系统，只在这里顺便提一句，就不展开了）。这两种模型的优劣，有相关的文章进行讨论，不是本文的重点。笔者的观点是，它们之间的差异与面向对象（O-O）的模式和函数式（functional）的模式之间的差异可以类比。
值得指出的是：采用了UTXO模型的系统，其交易之间实际上就有一个“链式结构”：一个交易的输出，成为另一个交易的输入，交易与交易之间就通过这个方式被串起来了。这样的链式结构，实际上是一个有向无环图（DAG），读者可以自行验证。同时，由于Corda系统的数据不是全局的，所以这样的“链”在系统中会存在多个，相互之间没有连接。因此，Corda系统中虽然没有“区块链”，但是仍然有“交易链”，这也就是笔者称Corda为“无链之链”的原因。

【交易（Transaction）】
交易就是状态转换的过程，简单地说是{输入状态、交易指令、输出状态}组成的元组，其中输入、输出都可以是一个状态列表。此外，交易还包括其他一些要素，如：附件、时间戳、各种签名以及为采用硬件加密的目的而使用的文字摘要（summeries），比较重要的部分都会在本文中讨论到。这一定义与其他“类区块链”系统中的交易定义区别不大，最主要的差异在于“交易指令”（command）这一概念，它描述的是这个交易具体是做什么的。
Corda的设计目标是对现实世界中各种交易类型进行支撑，因此要具有描述交易实际执行动作的能力，例如：转账、存入/提现、开票/兑付，诸如此类，所以要引入command这一概念。当然，这些交易动作只需要交易参与方事先约定就可以了，他们可以约定什么值表示什么含义，因此指令本身的具体值并不重要。Corda交易指令设计的关键要点是，指令必须包括有权作出这个指令的全部参与方的公钥用于后续的签名验证，并且允许交易的合约代码对此进行检查。比如说，资金转账的指令必须是某个银行才能执行，而开具一张承兑汇票的指令则可能需要开票方、承兑方都签署才能生效，这样一来接收这张汇票的一方，就可以通过事先编写的合约代码来实现这一检查。
有了指令机制，交易的合法性验证过程也更加清晰了：一个交易的全部指令所列出的所有参与方，就是一个交易需要签名的所有参与方。这是个充分必要条件，很好地解决了一个问题：交易到底需要验证哪些签名才被认为是有效的。同时值得提出的是，Corda的合约验证流程实现了合约与哈希算法之间的解耦——合约代码只需要判断事先约定的参与方的公钥是否都包含在此次交易的command当中，而对交易的全部签名的有效性（是否与这些公钥匹配）进行验证的工作留给Corda系统来做。这是Corda设计的一个特色，可以简化合约代码的开发和部署/升级工作，例如：一个合约对应的多次交易过程中系统的加密算法进行了升级，智能合约的代码是不需要改变的，这一点相对于比特币而言有一定优势。
除了command这一关键概念之外，Corda系统中交易还有很多特性，这里列出几个与Corda设计目标相匹配特点：
为了适应多方复杂交易的机制，Corda引入了联合公钥（Composite keys）的概念，系统中所说的需要keys的地方，都是指一个Composite key的结构。联合公钥是一个树状结构，叶节点表示来自一个参与方的一个公钥，而上层节点代表联合权重，用于表示必须有满足权重值条件的参与方签名才能认为该节点有效。例如：一个上层节点的权重为3，则意味着其下面节点必须有3个有效签名，这个节点才算有效。反过来说，一个权重为3的节点下面有5个参与方的公钥，也只需要3个签名有效，这个节点就有效。通过层层判断，到根节点形成一个组合条件，最终判断全部签名的总体有效性。联合公钥的概念如图1所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/58660ad6edf5b.png" alt="图1  联合公钥" title="图1  联合公钥" />
Corda的交易具有“半匿名”的能力，每一个状态都有他所属的参与方信息（party），这个信息包含两个“字段”：公钥和标识。只有公钥字段是任何时刻都必须有值的，一个新交易创建或者从磁盘上反序列化到内存中的时候，可以根据交易的参与方当前提供的身份来填充标识字段，这样就实现了交易参与者根据自身需要（和可接受的程度）来决定每一笔交易是实名的还是匿名的。另外，交易发送给Notary等节点进行签名时，也不需要传输标识字段，这样一来，即使一个交易本身是实名的，从全网的角度看仍然可以做到半匿名。
另外需要提及的一点，Corda中交易的类型有两种：普通交易和Notary变更交易。由于Notary概念还没有介绍，这里就不详细展开了，只要说明一件事：这两种交易类型的区别主要在验证流程，输入输出类型都是一样的，因而Corda的交易概念定义是唯一的。

【合约（Contract）】
合约就是交易双方事先达成的契约。从合约的角度看，交易其实就是它的一次执行过程，因此合约对交易有约束性，并且一个合约可以多次执行，也就是多个交易可以对应一个合约。
Corda的合约也就是我们常说的“智能合约”，本质上是一段代码，在JVM的体系中，就是一个类。合约都需要实现Contract这个Interface，这个接口有一个函数和一个属性：方法是verify，用于验证交易的合法性。这个函数接收TransactionForContract类型的参数，其中的关键点在于这个类型的构造函数的参数都是不可变参数类型，因此保证了Corda的合约都是“纯函数”——只能对交易起到验证作用，无法对被验证的交易产生任何副作用。
Contract的唯一属性：legalContractReference，是一个SecureHash类型的数据，用来存储现实世界中真实合约的标识。我们很容易想到：可以用这个值来存储合约文件实际内容的哈希值，用来保证对应合约内容的唯一性，很明显这是Corda系统与真实世界建立关系的一个连接点。
通过这样的结构，contract实现了它应该具有的两个能力：描述现实世界的合约，并且对根据这个合约进行的任何交易进行验证。从技术实现上来看，Corda的合约就是一个Java的class文件，可以被JVM执行，从而开发者可以使用JVM上的各种语言进行开发，合约代码中原则上也可以调用很多JVM上已有的类库、代码，这也是Corda的一大优势。在交易执行过程中，这个class文件必须作为交易的附件，是交易的输入条件之一，被系统加载并执行其verify函数。
这里需要再次强调的一点是：Corda的智能合约是“纯函数”，这一点和比特币类似，总体上就是说智能合约无法改变系统/交易的状态，即使无数次执行智能合约的代码，最终产生的结果都是一样的，系统状态也没有任何改变。

【Oracle】
Corda的设计理念之一就是要和现实世界发生联系，这种联系的能力前面已经看到了很多，Oracle则是这个理念的另一重要体现，这也是为什么笔者认为应该将其放在基本概念的范围来讲。股票价格、外汇牌价、银行利率，甚至一些非标准的信息（比如某家企业倒闭），都是“外部世界”发生的事实，而交易的过程和结果的验证，往往需要依赖这些信息。
Oracle（先知）就是这样一个角色——一个受信任的公共服务，用来将现实世界中的事实“注入”到Corda网络中，使之可以成为交易的一个输入项。具体实现方面，Corda将Oracle的行为模式设计成为对每一个交易进行事实的注入，而不是对整个系统进行注入。这样的设计有两方面的合理性，一方面是作为去中心化的数据库，恐怕也没有一个地方来登记所谓全局的信息了；另一方面从经济的角度讲，如果信息是全局的，一旦某个参与方获得了，就可以和其他人共享，Oracle就只有在发布信息的那个时刻才能获得报酬，经济利益方面没有保障将使得没有人愿意去承担这样的角色。因此，Oracle在每个交易中签署相应的内容，也成为Corda系统考虑现实世界经济活动特点的另一体现。
Oracle对整个交易进行签名的实现还带来了Corda当中另一个有普遍意义的概念：transaction tear-off，意思是说要把交易发给一个角色时，可以把不需要他知道的具体数据从发送的内容中删除，却仍然不影响他对整个交易签名。有了这个机制，就可以实现交易的隐私保护。那么，没有交易的全部数据，怎么实现对整个交易进行签名呢？为此，Corda将交易的签名结构做成一棵Merkle Tree，从而可以实现将一个保留了必要签名的分支发送给Oracle，使他仍然能按照签名结构完成对整个交易的签名。很显然，这基本上借鉴了比特币交易的签名实现机制，唯一不同的是，比特币用这种机制来节约磁盘空间的占用，而Corda用他来实现交易的隐私保护。

<strong>交易流程</strong>

【交易流（Flow）】
交易流（flow）是Corda系统的重要概念也是特色之一，简单说flow就是复杂交易的具体实现协议：如同比特币核心系统本身支持的动作只有“花钱”一样，Corda最基本的交易能力也只是{输入、指令、输出}。这样一来，现实世界中所出现的涉及多方的、多环节的、有条件的交易等复杂处理流程，只需要通过简单交易的组合、包装来完成。
由于Corda的交易通讯都是点对点的，而非全网广播的，因此交易流程实现起来相对简单、直接：就像一个流程图，我们只要描述节点之间的连接、数据传输的方向，以及从一个节点向下一个节点流转的条件等等，就可以设计出交易流程了。把这个流程通过代码实现，并且交由Corda系统去运行，就成了一个个在系统中的flow，支撑着Corda系统的日常运转交易处理，这实际上就是Corda系统的Dapp，又称CorDapp。
Corda有大量的内置flow，基本覆盖了日常交易流程中所用到的功能和典型交易的过程，例如：获取交易数据、变更Notary、交易组中确认，还包括典型的两个参与方的交易（模板）等等，都在net.corda.flows中定义。由于支持子流程调用，因此新开发一个flow需要的实际代码量应该也很少。
一个有意思的事情特别强调一下，Corda的flow实现，使用到了一个“黑科技”——quasar。这是一个JVM系统上实现fiber/co-routine形态的纤程/轻线程的类库，同时也是一套实现了actor模型的类库，可以说是目前actor领域内除Akka之外唯一一个比较有影响力的实现。Corda系统中主要是使用到了quasar的纤程能力，通过quasar字节码级别的注入，实现了一个flow的执行流程可以随时被挂起和恢复，并且挂起是可以在持久化层面实现的，从而大幅度提高了系统的可伸缩性和可靠性。由于quasar目前只对Java和Kotlin提供完整支持，对Clojure提供部分支持，对Scala等其他JVM语言的支持还相当不完善（Scala由于有Akka，对于quasar是不是感兴趣也是问题）。因此笔者相信，quasar应该是Corda采用Kotlin开发的最主要原因。不过，这里要回到开头提出过的一个话题：quasar的选用，显然是Corda作为一个系统在高并发和高可靠性方面的解决方案，与“类区块链”这个领域并没有本质的关系，因此这应该是本文唯一一个脱离区块链概念讨论的议题，主要是因为这个黑科技的吸引力还是蛮大的。


【Notary与共识机制】
Notary是Corda网络交易验证和确认的核心机制，这个机制的采用本质上想要解决两方面问题：一是避免因为分布式共识机制而导致交易信息在全网广播，这主要是为了支撑交易信息“适度可见”的能力。另一个目的是将共识机制与交易流程分开，变成一种标准服务，从而可以采用不同形态的共识实现方式，而非绑定到某种特定算法上。
1. Notary
Notary是公证人的意思，从字面上就能看出来其作用：就是有一个独立的、交易双方（多方）都信任的角色，来最终确认这笔交易的有效性。根据前面描述的基本概念可以知道，交易的输入、执行动作以及输出三者关系的有效性是通过智能合约来判断和保证的，因此本质上需要Notary进行判断和保证的就只有交易输入的有效性——某项输入数据没有曾经或正在成为其他交易的输入，也就是保证没有发生“双花”。从这个角度讲，Notary就是比特币的共识机制——区块链——的替代物。本质上讲，能采用Notary机制来替代区块链模式的共识机制，还是Corda的定位所决定的：一个半信任的网络，参与方和节点的加入都是可以事先经过审核的，即使存在恶意攻击，其种类和形态也和比特币面临的情况完全不同。
事实上，基于Notary进行交易确认的方式，最早是InterLedger提出的——由于InterLedger的目标是跨账本的交易，一个“类区块链”账本系统内部的节点共识算法是无法应用在不同账本之间的，为此必须有账本间认可的（半）信任中介来承担交易确认的职责，Corda的技术白皮书中也确认其Notary的概念来自InterLedger。
Notary的具体实现机制比较简单，交易参与方将交易发送给Notary，发送过程也采用flow的机制实现。Notary接收到交易后，根据自己以往记录的所有交易的输入，查询这个交易的输入是否曾经出现在另一个交易的输入项当中。如果确认这个交易的输入项都没发生过“双花”，则可以签署交易，此时交易就达到了最终生效（finality）的状态，也就完成了。如果Notary判断交易无效（其实就是发生了“双花”），就会返回异常，交易也就终止了。从这里也可以看出，使用Notary来做交易确认，本质上是要把交易的所有输入项发给他——由于系统的状态都是不可变的，所以只发输入项就够了。这也就解释了前面所提到的，Corda网络中的状态具有一个Notary属性，这个Notary是当初产生这个状态的交易验证时所使用的Notary。同时，为了实现上述验证过程，Corda网络也要求一个交易的输入项必须指向同一个Notary，也就是这个交易要提交验证的Notary。如果有些状态不是指向这个Notary，则首先要对这些状态执行Notary变更交易来实现转移。
此外，所谓单一的Notary服务，完全可以是一个网络，其中有多个Notary节点，但是他们依赖同一个数据库来存储信息，或者依赖一个能保证一致性的分布式数据。换句话说，只有各自独立运作，并不依赖一套数据存储的Notary，才能被认为是不同的Notary服务。上面提到的状态在Notary之间转移，指的是真正各自独立Notary之间的关系。
2. 共识机制
提到Corda网络的共识机制可能会有些奇怪，前面刚刚提到Notary从某种意义上说就是“信任中介”，是比特币的区块链模式共识机制的替代物，防止双花由它来保证，Corda网络怎么还会有共识机制呢？
我们首先看看InterLedgr提出的Notary相关的共识机制：由于多个账本的一连串交易应该会有多个中介，因此中介间也要达成共识，并且由于网络复杂性和没有统一的信任机制，这种共识算法也要能够防止拜占庭失效/攻击。
笔者通过对InterLedger描述的共识机制和Corda当中的相关描述，发现一个问题：基于Notary的网络，其“共识概念”存在着歧义：
1. 某个Notary服务本身作为一个分布式系统，节点之间受到网络的影响，可能存在拜占庭失效，这是一个技术问题。各个节点之间需要达到状态同步或者数据一致，需要一个BFT的算法，有时候也称为共识机制。
2. 多个真正相互独立的Notary，如果要共同参与某个交易，由于各自的信息掌握并不完整，如何来达成共识即这个交易没有发生“双花”？本质上这又回到了信息的全局可见性问题。
原则上来说，比特币层面的共识机制指的是后者，通过“信息全局可见+PoW+区块链”的方式实现了共识。目前无论是InterLedger还是Corda，所讨论的共识机制都是前者，这是一个很明显的歧义。网上有个精彩评论从另一个角度谈到了这一点：Corda网络的Notary可以有很多实现，其中比特币就可以作为Notary的实现——一个全球唯一的、相对低速的Notary；反过来也可以说，区块链就是比特币网络的全局唯一Notary。
由此可见，在Corda网络中，Notary机制的有效性是严格限定在其覆盖范围内的，更大范围的交易验证，必须依赖于一个更广范围的Notary的建立，或者多个原本无关的Notary的协同作业。而这一点，目前在Corda网络中没有给出参考实现或者实现方面的指导意见，因此Corda网络中Notary的使用、迁移和共识机制在实现层面仍有未解决/论述的问题。

<strong>网络结构简述</strong>

正如开头提到过的，Corda的实现与运行体系带有鲜明的Java生态环境的特点——最典型的就是一些（相对成熟的）开源框架与组件的组合。具体体现为：Corda网络通讯基于activemq的一个子项目artemis；节点的存储则直接支持通过JPA将交易等数据结构存储到数据库中；节点的管理直接自带了一个Web应用。这些特性使得Corda在企业中的运用变得相对简单，是Corda的主要优势之一。

【网络通讯】
P2P网络的节点功能当中，通讯机制是很重要的组成部分，准确地说主要包括两部分，一个是通讯本身的功能，如通讯协议、消息结构、序列化等；另一部分可以称为P2P协议，涉及节点发现、加入与退出，离线时的机制等。
首先说网络通讯本身，Corda的通讯协议基于AMQP/1.0，采用TLS作为加密协议。Corda目前的（参考）实现简单而清晰——内嵌了Artemis，这是Apache ActiveMQ的一个子项目，是一个支持AMQP/1.0（也支持JMS）的全功能的消息中间件，并且适合于嵌入式应用。通过这个手段，通讯本身的功能都得到了覆盖，既包括基本的网络通讯协议的支持（Artemis的通讯功能基于Netty）、消息格式解析，又包括消息持久化（提升可靠性）、队列管理（简化内部消息处理流程）等高级特性。从这个实现就可以看出基于Java生态环境的解决方案带来的好处：能够在短时间内解决重要的基础设施需求。
说到P2P协议部分，Corda采用了很简单的NetworkMapCache服务的概念，字面上理解起来比较容易，就是每个节点包含一个整个网络Map的缓存。这个缓存自然是分布式维护的，网络变动会通知到各个节点，更新Map，每个节点也都对外提供发现、注册等服务，并且要求一定的身份验证。具体到实现模式，文档中并没有详细说明，从代码当中也看不到对于某一种P2P网络库的引用和自动发现功能的实现。同时，代码注释中提到，未来希望采用Raft/Paxos模式的选举方式实现网络初始Map的产生，因此目前的Corda应该在启动阶段采用简单的初始/种子节点的方式，这也是正常的模式。
总体而言，Corda的网络通讯层面的功能，还是直接利用了现有Java生态环境中的成熟组件，实现了较为快速的开发，同时拥有了完备的基本能力。

【数据存储】
音——支持通过ORM的方式，将交易数据存储到标准（关系型）数据库中，并且是通过标准JPA接口。具体实现方面，Corda节点内置一个H2数据库，同时允许通过配置JDBC连接到任何标准数据库上。
从底层架构的角度看，Corda基本就是为了方便企业应用，完全开放了底层数据结构。一个金融机构完全可以通过把Corda的数据和自身业务数据放在一个数据库里的方式，实现数据层面的直接打通——通过SQL JOIN的方式对两部分数据进行统一查询。Corda的技术白皮书中对这种数据整合方式也是完全支持和鼓励的，明显是作为系统设计的一个目标，这与Corda的总体目标确实是一致的，也说明Corda的设计者们对于企业在采纳一个新的系统时所关注的应用整合场景非常了解。
例如：Corda当中的“钱包”称为Vault（保险箱），就是存储了所有交易的实际资产信息的地方。如上所述，保险箱作为节点的一部分，也是完全基于这个JPA机制实现数据存储的。这样做的好处就是上面所说的，企业完全可以在数据层面将内部信息系统与Corda的保险箱打通，通过各种成熟的SQL查询模式，来实现应用整合，提升整个业务流程的开发效率，降低数据转移、核对等成本。当然，笔者建议这样做的时候一定要注意安全性、可靠性，否则一旦出现破坏Corda节点的数据库，恢复难度肯定比一般数据库要大得多。

【节点管理】
Corda的节点自带一个Node Explorer，这是一个Web应用，主要完成两类功能：
1. 节点管理，包括查看当前节点状态的dashboard，能够查看与配置节点的基本参数，以及可以浏览全局网络的基本状况等。
2. 应用管理，包括查看当前交易的记录，尤其是包含了现金这种内置交易的部分功能，能够查看所有现金交易的情况，以及真正发起一个最基本的现金交易，如图2所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/58660b8e9fe0d.png" alt="图2  应用管理" title="图2  应用管理" />
由此可见，Corda的节点内置了很多应用层面的功能，既方便使用者开箱即用，又可以作为应用开发的例子，供使用者进行学习和在此基础上扩充。笔者认为这也是Java生态环境的优势之一，毕竟底层系统也运行在JVM上，使得上层应用的开发和部署成本都有所降低。

【网络节点小结】
综合上面三个主要特性，基本上可以认为一个Corda节点就是一个标准的Java企业应用，存储、通讯、管理三个核心维度都是满足企业对于一个典型的Java应用的期待。对于金融机构、企业而言，采用Corda实现业务目标的阻力相对而言要小得多，使用过程中与自身的业务整合可以说毫无压力，从这个角度讲Corda的节点设计是完全能够支撑其市场目标的。

<strong>应用开发 —— CorDapp</strong>

去中心化应用（decentralized app，缩写为Dapp）的概念，应该是以太坊最早提出的。Corda特意将系统的应用写成“CorDapp”，可见是在呼应这个概念。很显然，CorDapp作为运行在去中心化数据库上的应用，当然可以称得上去中心化应用。
CorDapp是一个plugin形态的应用，通过实现CordaPluginRegistry抽象类，给出自己调用的flow（显然这是安全机制的考虑）、对外提供的API（rest形态）、标准Web接口等，最终形成一个jar，运行在corda的节点上。前面在讲flow的时候已经提到过，本质上corda的应用才对应着以太坊和HyperLedger的“智能合约”，从运行机制上看，大家本质上也都是plugin形态，并没有太大差别。
Corda为应用开发提供了一个模板：cordapp-template，这是一个独立的工程，可以用来作为开发一个新App的样板。如果要了解更多的App功能，还是应该自己去运行并学习corda工程中的samples里面所带的例子。尤其是用IDEA去开发corda时，各个例子可以直接在IDE中快速启动，便于开发者快速了解一下corda应用的运行结果。
由于Corda的文档也一再强调应用开发层面的机制还在快速变化当中，因此本文仅就其基本的插件模型作出上述介绍，其他详细内容读者可以在开发过程中跟踪最新的代码和手册。

<strong>总结</strong>

【应有一席之地】
作为总结，我们首先给出Corda与其他区块链/类区块链解决方案几个方面特性的对比如表1所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/58660c28eb866.png" alt="表1  Corda与其他方案对比" title="表1  Corda与其他方案对比" />
结合上述对比、背景介绍和本文所述的内容，笔者认为可以得出一些结论。首先，Corda的根本目标是一个“去中心化数据库”，这既是他与其他区块链/类区块链系统最直接的关系，又是与所有“真正的”区块链系统最大的区别。其次，Corda的设计与实现，是在参考了成熟的区块链系统的一些标准概念和做法的同时，结合自身的目标定位做出了相应的取舍、改进和创新。第三，Corda所实现的新型的去中心化数据库，基本达到了其所宣称的三个主要目标：
1. 信息适度可见
2. 较高的系统性能
3. 与现实世界的连接
除此之外，Corda对于在企业内的开发、部署和管理考虑的比较周全，因此我们相信其足以成为类区块链系统在企业应用领域占有一席之地的基础平台。

【理想很丰满，现实很骨感】
客观地说，Corda也存在一些问题，主要有两个方面：
第一是过度考虑现实世界需求的倾向——Corda当中模拟现实世界多重角色、体系结构中各种与现实世界的接口，有时候甚至让人产生一种“根据很多客户提出需求进行设计”的感觉。这种设计理念往往是“成也萧何，败也萧何”，可能会因为外部环境的变化而失去生命力，开发过程中也容易纠结于无法统一各种复杂情况而陷入停滞，优劣参半。
另一方面的问题是：相对于其宏伟的蓝图，Corda很多具体实现的细节层面还略显初级——“理想很丰满，现实很骨感”。当然，我们了解，除了以太坊之外，其他的类区块链系统的实现也都还处于非常初级的阶段，并不一定比Corda更完善。但是，由于Corda在去中心化数据库的核心理念——共识机制方面的“创新”，使得其这方面的实现必然更加为人们所关注。遗憾的是，笔者认为这方面的设计和实现，Corda还都有未解决的问题，不得不说在创新之路上任重而道远。
最后，笔者认为，一个好的类区块链/去中心化数据库系统，应该适度设计，具有一定的简单性：最主要的是将P2P网络、交易签名验证、拜占庭容错与补偿等核心机制进行整合，形成一个边界清晰的系统。在此基础上，如果特别关心性能、信息适度可见等特性，则可以引入Corda或者其他系统在这方面的设计理念进行扩充。重要的是，将上述特性在系统内部给出完善的实现（如果允许可插拔的实现机制，要有精确的接口和操作流程定义），并对外提供简单清晰的API。通过这样的方式，将可以构建出新一代面向价值转移的互联网基础设施，将分布式计算的能力发挥到一个新的层次。人类传播史上，经历了语言、书写、印刷、电子、互动等5次革命，区块链的出现将把人类带入价值传播的新时代。亿书（英文名Ebookchain），是目前国内唯一一款专注于版权保护的区块链产品，本文通过简单介绍亿书产品的实现，分享区块链在版权保护方面的探索与实践。  

<strong>版权保护的困局和传统方法的局限</strong>

随着互联网，特别是移动互联网的发展，数字出版已经形成较为完整的产业链，给网络作家等相关参与方带来可观的收入。但另一方面，侵权盗版制约着数字出版的进一步发展，各参与方都深受其害。特别是作者等内容生产商一直处于弱势地位，缺少相应的话语权和主导权，创作积极性倍受打击。面对这些问题，国家非常重视，各种政策和扶持计划频出，重拳解决版权保护难题，但是限于技术手段，很难从根本上解决。
传统的版权保护手段非常有限。历史上，有过使用邮戳实现版权保护的方法，即作者把写好的文稿，一式两份同时寄出，一份给出版机构，另一份邮寄给自己。当出现被盗用的情况时，就拿出自己手里的那一份作为诉讼的证据，因为邮戳时间一致、内容一致。到了今天，互联网时代崛起，免费分享盛行，版权保护一度被忽视。当引起人们足够重视的时候，却发现并没有十分可靠的办法，特别是在分享环节更是无能为力。 比如，人们熟知的CSS/AACS、Key 2 Audio、Always-Online DRM等比较知名的DRM技术，虽然有一定的保护作用，但屡屡被破解，也为分享带来壁垒，甚至演变成商家垄断的工具，引起用户，特别是支持正版的用户的强烈反感和抵触。
难道，真的如某些人所说，版权保护是无解的吗？非也。区块链技术的出现，给彻底解决版权保护顽疾带来了希望，更足可以让盗版无所遁形。目前，市场上已经出现一些基于区块连技术的解决方案，但多数是从传统角度切入的，其中亿书，是国内最先采用真正区块链技术，从创作、分享，到数字出版等各环节都有解决办法的综合解决方案。

<strong>区块链在版权保护上的主要特点</strong>
区块链基于数学原理解决了交易过程中的所有权确认问题，对价值交换活动的记录、传输、存储结果都是可信的。区块链记录的信息一旦生成将永久记录，无法篡改，除非能拥有全网络总算力的51%以上，才有可能修改最新生成的一个区块记录。
那么很显然，我们可以根据区块链的特点，结合版权保护的各个环节分别去理解下面三个方面的问题。
1. 如何进行版权注册？我们知道“可信时间戳”，由权威机构签发，能证明数据电文在一个时间点是已经存在的、完整的、可验证的，是一种具备法律效力的电子凭证。对于原创作品的登记，区块链技术可以非常方便地把时间戳与作者信息、原创内容等元数据一起打包存储到区块链上。而且，它打破了现在的从单点进入数据中心去进行注册登记的模式，可以实现多节点进入，方便快捷。
2. 如何解开版权确认的难题？所有涉及版权的使用和交易环节，区块链都可以记录下使用和交易痕迹，并且可以看到并追溯它们的全过程，直至最源头的版权痕迹。更主要的是，区块链所记录的版权信息是不可逆且不可篡改的。公开、透明、可追溯、无法篡改，保证了信息的真实可信，辅以简单易用的查询工具，版权确权就是非常简单的事情了。
3. 如何进行版权验证？区块链技术大量使用密码学技术，版权持有者在把作品写入区块链时，自动用自己的私钥对作品进行了数字签名，第三方可以用版权持有者的公钥对数字签名进行验证，如果作品的数字签名值验证通过，则表明此作品确实是版权持有者所有，因为只有版权持有者才有私钥能生成该签名值。另外，也可以使用杂凑密码算法SHA256计算作品的数字指纹，通过数字指纹比对验证版权情况。再者，辅以分布式检索等基于内容的技术手段，便可覆盖各类复杂验证情况。
很显然，区块链很轻松就能解决当前版权保护的注册、确权和验证问题。

<strong>亿书在版权保护上的基本实现</strong>

下面，我们拿亿书为例，来探讨区块链在版权保护方面的实现思路。
【基本的架构设计】
从架构设计上来说，可以简单分为三个层次，协议层、扩展层和应用层。其中，协议层又可以分为存储层和网络层，它们相互独立但又不可分割，如图1所示。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/58660d588001b.png" alt="图1  架构设计" title="图1  架构设计" />
所谓的协议层，是指最底层的技术。这个层次类似于我们电脑的操作系统，它维护着网络节点。这个层次是一切的基础，构建了网络环境、搭建了交易通道、制定了节点奖励规则。扩展层类似于电脑的驱动程序，是为了让区块链产品更加实用，可以使用分布式存储、机器学习、物联网、大数据等技术，这个层面与应用层更加接近，也可以理解为B/S架构的产品中的服务端（Server）。这样不仅在架构设计上更加科学，让区块链数据更小，网络更独立，同时也可以保证扩展层开发不受约束。应用层类似于电脑中的各种软件程序，是真正面向普通用户的产品。
限于当前区块链技术的发展，只能从协议层出发，把目标指向应用层，同时为第三方开发者提供扩展层的强大支持。
【产品工具化】
从上面的架构我们可以知道，面向用户的仅仅是一个客户端软件。当然，这个软件可以非常多样化。比方提供一个简单的写作工具，配合底层的协议，为作者提供一个从创作到发布，再到电子书出版的全流程解决方案。这样作者的整个创作过程都会被智能化的保存到区块链上去，一方面简化了操作，另一方面为作者打造了一个真正的自媒体平台。

【记录创作时间段】
很多人都会有这样的疑惑，如果A写的一篇文章被B上传到区块链，那么这所谓的版权保护岂不是在保护盗版了。实际上，如果单一的注册备案功能的话，必然会存在这样的问题，区块链仅仅是一项技术，再强大也无法处理链外的数据信息。因此，最好的做法自然是让作者直接在链上工作，变记录单点时间戳为记录时间段，从而避免单点记录时元数据单一无法佐证的弊端。
亿书会忠实记录作者内容创作过程中的关键信息，把单一时间戳汇成时间段，写入区块链。对于那些被盗版直接上传的数字作品，自然有了更多的可以检索验证的条件和信息。
实践中，亿书对作者撰写的作品通过密码技术手段，使用椭圆曲线密码编码学（ECC）对作品进行数字签名，同时用杂凑密码算法（比如SHA256算法）生成作品的数字指纹，加上可信的时间戳以及作者真实姓名等信息，一起写入区块链，得到其他节点的确认，从而保证数据的可信及不可篡改。

【追踪流通全过程】
互联网鼓励分享，版权保护也绝不应该是在封闭状态下的保护。在没有区块链存在的情况下，流通过程中的验证、取证是非常困难的事情，因为盗版信息随时都可能被修改、删除。另外，一般网站也不会提供技术验证的手段，所以给调查取证带来很大困难。无法取证，甚至取证不可信等都给维权带来极大不确定性。
<img src="http://ipad-cms.csdn.net/cms/attachment/201701/58660df1a6894.png" alt="图2  功能和产品" title="图2  功能和产品" />
亿书基于区块链技术，很容易解决这个问题。一方面，在分享、交易等过程中，亿书会忠实记录下全部痕迹，并可轻松追溯它的全过程，直至源头。这一点，轻松解决了人工追溯的繁琐过程，而且正确性、可信度和取证效率都是不可比拟的。其次，区块链对原始信息使用了加密技术以及电子签名技术，从技术上对版权信息做进一步的验证处理，这为取证提供了更加有效的技术手段。第一，亿书基于P2P网络，任何一个地方，只要能够联网到亿书网络，就可以使用亿书工具进行直接地验证和取证，便利性大大提高。第二，区块链技术可以把人的力量发挥到极致。亿书优化奖惩规则，鼓励人们举报和反馈。技术上模糊不清的，就可以通过利益驱动，让人参与进来，目前也只有区块链技术可以做到，做得彻底。这为主动防御盗版提供了更加深入细致的方法手段，将盗版防范于无形 。
举个例子，很多人都玩过Xbox360，大部分玩家都不愿意破解机器玩盗版游戏。原因是破解了Xbox360，有可能被Xbox Live封帐号，再也无法联机玩多人游戏了。为了保证正版率，越来越多的游戏开发商也开始仿效微软的这一做法，不再重视单机游戏，将心血倾注到了多人联机游戏开发上，这里面除了技术层面的演进，还有用户利益层面的驱使。那么，文字、图片、音乐等，这类没有单机模式、联机模式一说的内容怎么办呢？显然，需要一个基于分布式网络和分布式存储的区块链产品。

<strong>当前背景下的误区</strong>

【区块链技术法律会认可吗？】
互联网产品本来是技术上的实现，与简单的页面截图等证据手段相比，区块链的证信和可靠性是显而易见的，但是涉及到版权，有人质疑区块链技术是否被认可。对此，可以从两个方面给予明确的回答：
1. 工信部在2016年10月21日发布的《中国区块链技术和应用发展白皮书》中，“3.4区块链与文化娱乐”一节，专门描述了区块链技术如何用于版权保护，明确了区块链技术用于版权保护在司法取证中的作用。
2. 笔者在今年8月参加了“2016中国区块链产业大会”，其中专门有一个分会场，主题是《文体卷——支持文化金融发展》，该分会场的嘉宾包括国家知识产权局的相关领导，以及版权保护领域的各界专家、学者和从业人员。可以说，国家层面正在积极推动区块链在版权保护方面的应用。

【版权保护与免费分享矛盾吗？】
很多人认为，互联网的存在应该是免费分享，版权保护是要收费或被封闭起来才能保护，那岂不是相互矛盾？实际上，“免费”不代表不需要版权保护。笔者写的《Node.js开发加密货币》通过互联网免费分享，任何人都可以免费阅读，如果有人分享这些文章用来盈利（商用），那就触犯了本人的版权保护协议，是可以通过法律途径追究他的法律责任的。
在2016区块链产业大会上，与会的国家版权局的领导是这样回答版权保护与免费分享问题的：
1. 从国家发展角度来说，版权不能得到保护，知识创新被任意免费分享，就会严厉打击创作者的积极性。一个国家、一个民族的创新基因将被吞噬，这个问题在目前的中国已经足够严重，必须出重拳、出奇招解决。
2. 从国外的情况来看，美国的版权保护做的最好，但是美国的网络发展也是最好的，事实上，绝对不会出现“版权保护严格，网络发展就会受限”，这种此消彼长的怪现象。相反，版权得到了保护，大家的创新热情更高，主动分享的意愿和动力反而更足。
3. 从概念上讲，版权保护，并不等于知识不分享，版权保护有很多种方法，国家也在鼓励各类创新技术应用。

【区块链技术提倡匿名与版权保护实名的要求不矛盾吗？】
区块链是一项技术，匿名并非它的必要条件。版权保护是现实需求，实名则是必须的。确实很多项目是匿名分享，毕竟实名认证存在诸多壁垒，前期很容易让用户抵触。不过，无论要不要版权保护，首先都要尊重法律，尊重用户，保证不负责任的内容无法分享。当然，不提倡并不代表不可以，只是匿名分享会有诸多限制。

<strong>区块链技术自身的障碍与不足</strong>

从技术层面来说，当前区块链的处理能力普遍不高，存在瓶颈，我们通过优化已经大大提高了这一数值，但是仍然无法应对大规模的交易数据和交互流量，还需要进一步优化底层协议，扩展应用层开发。
其次，另一个技术难点是区块链主链的存储与分发技术。比特币的区块链大小已经接近60G，普通用户使用一个全客户端，同步这么大的数据量要耗费很长的时间。任何一款区块链产品，也都存在区块链数据不断膨胀的问题。亿书采取主链与侧链分离的架构设计，但在未来的某一天，仍然无法规避这个问题，这也需要不断的加以优化改进。
最后，区块链技术是集网络编程、分布式算法、密码学、数据存储技术等各类先进技术于一体的综合架构，技术难度大、人才培养周期长、高水平人才极度匮乏等等都是限制这个行业快速发展的重要因素。此外，当前区块链领域野蛮发展，劣币驱逐良币的现象不断上演，真正沉下心来做产品的团队，总是会面对多方面的压力和无脑黑，政策的监管和国家的扶持亟待尽快出台。加之，版权保护领域，涉及到创作者、使用者和出版发行机构等各参与方，要想快速发展，也需要国家政策层面的大力支持。众所周知，区块链技术还处在不断完善和发展的阶段，成熟的商业化应用尚未大规模出现，国际上众多领先的IT互联网企业已积极投入到区块链技术的研究和推广工作之中，京东也已着手开展区块链的研究和应用工作。下面，我将着重为大家分享区块链在零售供应链领域的研究心得和应用畅想。

<strong>零售供应链所使用的技术和不足</strong>

零售供应链涉及商品选取、采购、定价、库存、销售、配送所涉及到的所有环节，往往表现出多主体、多区域、长时间跨度、大量交互协作的特征，而整个供应链运行过程中产生的各类信息被离散地保存在上下游企业各自的系统内，信息流不透明且极易被篡改，客户和买家缺少一种可靠的方法去验证及确认他们所购买的产品和服务的真正价值，这也就意味着他们支付的价格无法准确地反映产品的真实成本。同时，很难去对重点事件进行全程有效追踪或是对事故进行快速精准的调查。这是现有供应链一个典型的问题。
为了提升数据真实性和有效性，很多企业引入了自动化设备和系统进行信息的采集和存储，但由于是企业各自主导进行，信息基准不统一，很难进行有效协同，而且企业对自己的信息拥有100%的修改和删除权限，导致信息的可信度完全建立在企业自我合规管理能力和品牌信誉之上，存在严重的潜在性系统风险。另外，一旦发生事故导致企业数据完全丢失，将很难进行恢复。另一方面，为了进行供应链企业间的快速协同，很多企业也在通过EDI数据对接等方式开展信息交换，这首先就要求企业具备很高的数据对接能力和运维能力，对于目前中国众多的中小企业，甚至某些中大型企业来说，仍然颇具挑战。与此同时，企业间的数据对接只能是端到端逐个进行的，以京东为例，我们有超过10万合作商家，每个商家因其业务形态和对接需求的不同，随之开展的对接适配工作也不同，后期的运维工作量更是绵长而巨大。

<strong>区块链技术相比传统方式的优势</strong>

区块链技术有望以低成本、高效率的方式彻底解决以上问题，改变业务乃至机构的运作方式。区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算范式。
利用区块链技术，企业可以确保商品和交易信息的绝对安全，同传统方式相比，区块链的密码学特性和分布式存储特性可以确保信息无法被恶意篡改，通过设定查询权限，可以轻松实现数据加密和授权浏览，同时，一旦某个节点数据完全丢失，可以基于分布式账本实现数据的快速恢复，为企业内部信息管理提供有力的安全保障。区块链所具有的数据不可篡改和时间戳的存在性证明的特质能很好地运用于供应链溯源防伪。例如，可以用区块链技术进行奢侈品钻石身份认证及流转过程记录——为每一颗钻石建立唯一的电子身份并存放至区块链中。这颗钻石的来源出处、流转历史记录、归属以及所在地都会被忠实的记录在链，只要有非法的交易活动或是欺诈造假的行为，就会被侦测出来。此外，区块链技术也可用于生鲜、药品、艺术品等的溯源防伪。试想一下，未来我们在购物后，可以轻松的知道自己购买商品的全部真实可溯的信息，不必担心假冒伪劣、食品安全、囤积居奇，真正实现好物低价、买的放心、吃的安心。企业也可以通过消费者在区块链上的反馈，进行有针对性的服务改进，创造更好的服务体验。
在企业间协同方面，区块链技术同样发挥着革命性的重要作用。零售供应链的企业之间，可以通过区块链共享某些关键性共识信息，从而保证这些信息在供应链中的高度一致和可信赖性；基于云端的区块链，无需繁杂的数据对接和大量运维工作，即可轻松实现企业间的价值流转和高效协同；基于区块链的自动化智能合约可以实现给定供应商或经销商的合约条款数字化，使计算机可以在达到约定条件后自动执行程序，轻松实现支付货款、扣除罚金等工作。同时，因为区块链具有不可篡改、可追溯和基于密码学的公私钥安全体系，交易双方完全不用担心交易记录被恶意篡改、无法查询或被公开给不相关的第三方。

<strong>区块链技术在商业化实现中的难点与障碍</strong>

首先，区块链技术本身的发展还不成熟，特别是分布式账本和共识机制带来的算力消耗和存储空间大量占用的题，仍然需要找到更为有效的解决方案。
其次，作为新兴技术，要实现商业化，必须基于具体的应用场景，联合相关的企业、监督机构共同投入才能最终落地。重点和难点在于如何向参与的企业决策层展示区块链技术的优势和发展潜力，从而充分获得支持和投入；如何联合优质供应商共同参与区块链建设和高效运营工作，获得供应商的积极配合和信任。技术的发展离不开企业的商业化应用场景，更离不开广大科研机构和爱好者的持续投入、关注和宣传，任何能提升用户体验及成本效率的技术，都将拥有广阔的发展空间。